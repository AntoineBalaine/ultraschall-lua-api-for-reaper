<html><head><title>
Ultraschall API functions
</title>

</head><body>
<div style="position:absolute; top:5%; padding-left:5%; width:90%;">
<hr><table width="100%"><td style="position:absolute; right:0;">Automatically generated by Ultraschall-API 4.00 Beta 2.7 - 28 functions available</td></table><br><hr><h2><img src="gfx/us.png"> - John Cage "4:33" - Functions Reference</h2>Beta 2.7 - 15th of October 2018 - Build: 16066<h3>The Functions Reference</h3><table style="font-size:10pt;" width="100%"><tr><td>&nbsp;</td></tr><tr><td><b>API-Variables</b></td></tr><tr><td><a href="#Introduction_API_Variables">API-Variables</a></td>
</tr><p><tr><td>&nbsp;</td></tr><tr><td><b>Arrangeview Snapshots</b></td></tr><tr><td><a href="#Arrangeview_Snapshots_HowToRestore">Arrangeview Snapshots: How to restore</a></td>
<td><a href="#Arrangeview_Snapshots_HowToStoreRetrieveDelete">Arrangeview Snapshots: How to store, retrieve, delete</a></td>
<td><a href="#Arrangeview_Snapshots_Introduction">Arrangeview Snapshots: Introduction</a></td>
</tr><p><tr><td>&nbsp;</td></tr><tr><td><b>Datatypes</b></td></tr><tr><td><a href="#Datatypes_CheckingDatatypes">Datatypes: Checking Datatypes</a></td>
<td><a href="#Datatypes_EnvelopePointArray">Datatypes: EnvelopePointArray</a></td>
<td><a href="#Datatypes_EnvelopePointObject">Datatypes: EnvelopePointObject</a></td>
<td><a href="#Datatypes_Introduction">Datatypes: Introduction</a></td>
</tr><tr><td><a href="#Datatypes_MediaItemArray">Datatypes: MediaItemArray</a></td>
<td><a href="#Datatypes_MediaItemStateChunkArray">Datatypes: MediaItemStateChunkArray</a></td>
<td><a href="#Datatypes_trackstring">Datatypes: Trackstrings</a></td>
</tr><p><tr><td>&nbsp;</td></tr><tr><td><b>Introduction</b></td></tr><tr><td><a href="#Introduction_Api">Introduction to the Ultraschall API</a></td>
<td><a href="#Introduction_Bugreporting_FeatureRequests">Introduction: Bugreporting and Feature Requests</a></td>
<td><a href="#Introduction_How_to_Use">How to use the Ultraschall API</a></td>
<td><a href="#Introduction_How_to_Use_Beta_Functions_And_Hotfixes">How to use Beta functions and hotfixes</a></td>
</tr><tr><td><a href="#Introduction_License">Introduction: License</a></td>
</tr><p><tr><td>&nbsp;</td></tr><tr><td><b>MediaItems</b></td></tr><tr><td><a href="#Getting_Manipulating_Items_GetMediaItems">MediaItems: Getting MediaItems by Time and Tracks</a></td>
<td><a href="#Getting_Manipulating_Items_Introduction">MediaItems: Introduction</a></td>
</tr><p><tr><td>&nbsp;</td></tr><tr><td><b>Navigation</b></td></tr><tr><td><a href="#GetSetStates_Project_Track_Item_Env_Introduction">Get/Set States for Project, Tracks and Items: Introduction</a></td>
<td><a href="#Navigation_Autoscroll_Followmode">Navigation: Autoscroll and Followmode</a></td>
<td><a href="#Navigation_CenterView">Navigation: Center View</a></td>
<td><a href="#Navigation_GotoMarkersRegionItemEdges">Navigation: Go to markers, regionedges and itemedges</a></td>
</tr><tr><td><a href="#Navigation_Introduction">Navigation: Introduction</a></td>
<td><a href="#Navigation_MovePlay_and_Editcursor">Navigation: Move Play and Editcursor</a></td>
</tr><p><tr><td>&nbsp;</td></tr><tr><td><b>Rendering</b></td></tr><tr><td><a href="#Rendering_01_Introduction">Rendering: Introduction</a></td>
<td><a href="#Rendering_02_About_Renderstrings">Rendering: About Renderstrings</a></td>
<td><a href="#Rendering_03_About_Renderingfunctions">Rendering: About Rendering-functions</a></td>
<td><a href="#Rendering_04_Change_more_render_settings">Rendering: 04_ Change more render-settings</a></td>
</tr><tr></tr><p></table><hr><a id="Introduction_Api"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">The Ultraschall-Extension is intended to be an extension for the DAW Reaper, that enhances it with podcast functionalities. Most DAWs are intended to be used by musicians, for music, but podcasters have their own needs to be fulfilled. In fact, in some places their needs differ from the needs of a musician heavily. Ultraschall is intended to optimise the workflows of a podcaster in Reaper, by reworking it with functionalities for the special needs of podcasters.<br> <br> The Ultraschall-Framework itself is intended to include a set of Lua-functions, that help creating such functionalities. By giving programmers helper functions to get access to each and every corner of Reaper. That way, extending Ultraschall and Reaper is more comfortable to do.<br> <br> This API was to be used within Ultraschall only, but quickly evolved into a huge 600+ function-library, that many 3rd-party programmers and scripters may find use in, with many useful features, like:<br> <br> - Rendering - you can render your projects without having to use the render-dialog. You can customize the rendering-workflow in every way you want.<br> just create a renderstring and pass it over to <a href="#RenderProject_RenderCFG">RenderProject_RenderCFG</a> or <a href="#RenderProjectRegions_RenderCFG">RenderProjectRegions_RenderCFG</a><br> - Navigation, Follow and Arrangeview-Manipulation - get/set cursors, zoom, autoscroll-management, scroll, etc<br> - ArrangeView-Snapshots - you can save, retrieve snapshots of the arrangeview, including position, zoomstates to quickly jump through parts of your project<br> - Trackstates - you can access and set all(!) track-states available<br> - Mediaitem-states - you can access and set many mediaitem-states (more will follow)<br> - ItemExtStates/TrackExtStates - you can save additional metadata easily for specific tracks and items using ItemExtStates and TrackExtStates<br> - File access - many helperfunctions for reading, writing, copying files. No more hassle writing it yourself!<br> e.g <a href="#ReadFullFile">ReadFullFile</a>, <a href="#WriteValueToFile">WriteValueToFile</a>, etc<br> - Cough-Mute-management - you can write your own cough-buttons, that set the state of the mute-envelope of a track easily<br> - Marker - extensive set of marker functions, get, set, export, import, enumerate, etc<br> - Spectrogram - you can program the spectrogram-view<br> - Get MediaItems - you can get all media-items within a time-range AND within the tracks you prefer; a 2D-approach<br> e.g. <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a> and <a href="#GetMediaItemsAtPosition">GetMediaItemsAtPosition</a>, etc<br> - Gaps between items - you can get the gaps between items in a track, using <a href="#GetGapsBetweenItems">GetGapsBetweenItems</a><br> - Edit item(s) - Split, Cut, Copy, Paste, Move, RippleCut, RippleInsert, SectionCut by tracks AND time/start to endposition<br> e.g. <a href="#RippleCut">RippleCut</a>, <a href="RippleInsert" class="uri">RippleInsert</a>, <a href="#SectionCut">SectionCut</a>, <a href="#SplitMediaItems_Position">SplitMediaItems_Position</a>, <a href="#MoveMediaItemsBefore_By">MoveMediaItemsBefore_By</a>, <a href="#MoveMediaItemsSectionTo">MoveMediaItemsSectionTo</a> and many more<br> - Previewing MediaItems and files - you can preview MediaItems and files without having to start playback of a project<br> - KB-Ini-Management - manipulate the reaper-kb.ini-file with custom-settings<br> - Checking for Datatypes - check all datatypes introduced with Ultraschall-API and all Lua/Reaper-datatypes<br> - UndoManagement - functions for easily making undoing of functions as well as preventing creating an undo-point<br> - RunCommand for Items/Tracks - apply actions to specific items/tracks<br> - Checking for changed projecttabs - check, if projecttabs have been added/removed<br> - ExtState-Management - an extensive set of functions for working with extstates as well as ini-files<br> - Data Manipulation- manipulate many of your data, including bitwise-integers, tables, etc<br> - Clipboard-Management - get items from clipboard<br> - Error Messaging System - all functions create useful error-messages that can be shown using, eg: <a href="#ShowLastErrorMessage">ShowLastErrorMessage</a>, for easier debugging<br> <br> tons of other helper-functions AND<br> <br> it's documented with this documentation. :D<br> <br> Happy coding and let's see, what you can do with it :D<br> <br> Meo Mespotine (mespotine.de)<br> <br> For more information about Ultraschall itself, see <a href="http://www.ultraschall.fm">ultraschall.fm</a> and if you want to support us, see <a href="http://www.ultraschall.fm/danke">ultraschall.fm/danke</a> for donating to us.<br> <br> PS: In this documentation, I assume you have some basic knowledge in Lua and in using Reaper's own API-functions. Explaining both of these is beyond the scope of this doc.<br> <br>
</divl></table><br><hr><a id="Introduction_How_to_Use"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Using the Ultraschall-API is quite easy.<br> <br> First make sure, you use the right versions of Reaper and SWS:<br> Reaper 5.95 and SWS 2.9.7<br> You can download them at <a href="http://www.reaper.fm">reaper.fm</a> and <a href="http://www.sws-extension.org">sws-extension.org</a> respectively.<br> <br> 1) Just download the zip-file of the current version from <a href="http://api.ultraschall.fm">api.ultraschall.fm</a>.<br> 2) Extract it to the UserPlugins-folder in the Resources-folder of Reaper. You can find the correct Resources-path in the Reaper-menu &quot;Options -&gt; Show REAPER resource path in explorer/finder...&quot;.<br> The folder UserPlugins should contain the folder ultraschall_api and the files ultraschall_api_readme.txt and ultraschall_api.lua<br> 3) Now create a new script, by opening the Actions-window (Menu: Actions -&gt; Show action list) and clicking the New-button next to &quot;ReaScript:&quot;, give it a name and hit save.<br> <br> Now include the following line in your script at the beginning:<br> <br> '''<br> dofile(reaper.GetResourcePath()..&quot;/UserPlugins/ultraschall_api.lua&quot;)<br> '''<br> <br> Now you can program with the Ultraschall-API. Just add the functions AFTER the dofile-line.<br> <br> 4)To test, if it's successfully installed, add <br> <br> '''<br> ultraschall.ApiTest()<br> '''<br> <br> after the dofile-line and hit ctrl+s or cmd+s(on mac).<br> <br> The script should show a messagebox, that tells you, which of the Ultraschall-API-parts are activated. If it shows, everything works fine :)<br> <br> If you are already familiar with programming Reaper's own API-functions, you know, that all of Reaper's functions are placed in a table called &quot;reaper.&quot;<br> e.g. reaper.ShowConsoleMsg(&quot;msg&quot;)<br> <br> The Ultraschall-API is quite the same, but is using the table &quot;ultraschall.&quot; instead.<br> e.g. ultraschall.ApiTest()<br> <br> See the functions-reference for all available functions or read on in this documentation for a collection of concepts introduced by the Ultraschall-API.<br> <br>
</divl></table><br><hr><a id="Introduction_How_to_Use_Beta_Functions_And_Hotfixes"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Before a new version of the Ultraschall-API is finished, it is in beta-stage. But sometimes, bugs need to be fixed even before a new release is done or you may want to test new functions from the next release for bugs and quirks.<br> So I added two ways to deal with that.<br> <br> 1) Hotfixes<br> Hotfixes are available at <a href="http://api.ultraschall.fm">api.ultraschall.fm</a>. They provide fixes for functions and bugs that came across after a release, but no new functions.<br> Just download the ultraschall_hotfixes.lua and put it into UserPlugins/ultraschall_api-folder.<br> The chance is high, that there is already an ultraschall_hotfixes.lua-file in the folder. You can safely overwrite it.<br> Voila, you have added the most recent bugfixes.<br> <br> To get the bugs back, just delete the ultraschall_hotfixes.lua.<br> <br> All fixes in ultraschall_hotfixes.lua will be part of the next full version of the Ultraschall-API.<br> <br> Check again from time to time to get the latest hotfixes.<br> <br> 2) Beta-functions and features<br> Beta-functions are functions intended for a future release of the Ultraschall-API. If you want to test them, just download the latest Beta-Pack from <a href="http://api.ultraschall.fm">api.ultraschall.fm</a>.<br> Extract the files in the Beta-pack to UserPlugins of the Resources-folder of your Reaper-installation. Voila, the beta-functions are installed.<br> <br> To use them, you need to explicitly turn them on in your script, using the following lines:<br> <br> '''<br> ultraschall.US_BetaFunctions=&quot;ON&quot; -- Only has an effect, if ultraschall-beta-functions exist in Scripts-folder<br> -- Turn ON, if you want BETA-Api-Functions<br> '''<br> <br> The documentation for beta-versions can be found at <a href="http://api.ultraschall.fm/US_Beta.html">api.ultraschall.fm/US_Beta.html</a><br> <br> Be aware, they are in beta-stage. They will probably change, disappear or be exchanged with better functions. Beta-functions are only for testing purposes, not for productive coding!<br> <br>
</divl></table><br><hr><a id="Introduction_Bugreporting_FeatureRequests"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">If you find any bugs or itches and want to report them, I suggest you the following procedure:<br> a) Make notes of: what operating-system you use(Mac, Win, Linux), which Reaper-version, which SWS-Version and which Ultraschall-Framework-Version.<br> b) Write down, what you wanted to do, what you expected to happen and what has happened instead. Make it as detailed as possible(a code-fragment that triggers a bug, a screenvideo i.e. would be perfect), as more information helps to find out, where the problem lies. It's always better to write too much, than the other way around.<br> Please keep in mind when sending code-fragments: they need to be able to trigger the bug without any of your other code. And please don't send me hundreds of lines of your code, as I can't debug it for you. Just concentrate on the line(s), that trigger the bug successfully.<br> c) Send these notes either as:<br> Issue at the GitHub-Repository of the Ultraschall-API(preferred): <a href="https://github.com/Ultraschall/Ultraschall-Api-for-Reaper.git" class="uri">https://github.com/Ultraschall/Ultraschall-Api-for-Reaper.git</a><br> eMail: lspmp3@yahoo.de(for framework-related stuff only!!) <br> Sendagate: <a href="http://www.sendegate.de">sendegate.de</a> into the Ultraschall-section.<br> <br> Bugreports that contain only a &quot;it doesn't work&quot; and &quot;I expected it to work&quot; will be ignored gracefully ;)<br> <br> If you have feature-requests, we have open ears. Keep in mind, not everything you find a good idea actually is one. So we may or may not take on your idea, change and rework it into a way, that benefits all, not just your particular use-case. When in doubt, just try it!<br> Keep also in mind: there are limitations. Some cool features we all would love to have, simply aren't implementable. Que sera, sera...<br> <br> For your comments just send a mail at: lspmp3@yahoo.de(for framework-related stuff only!!) or go to sendegate.de into the Ultraschall-section.<br> <br> PS: If you know how to implement impossible things or do things better than the current implementation, you are welcome to donate your improved codes. :)<br> <br>
</divl></table><br><hr><a id="Introduction_License"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;"><p id="section"><br>
<h1 id="section-1"><br></h1>
<h1 id="copyright-c-2014-2018-ultraschall-httpultraschall.fm">Copyright (c) 2014-2018 Ultraschall (http://ultraschall.fm)<br></h1>
<h1 id="section-2"><br></h1>
<h1 id="permission-is-hereby-granted-free-of-charge-to-any-person-obtaining-a-copy">Permission is hereby granted, free of charge, to any person obtaining a copy<br></h1>
<h1 id="of-this-software-and-associated-documentation-files-the-software-to-deal">of this software and associated documentation files (the &quot;Software&quot;), to deal<br></h1>
<h1 id="in-the-software-without-restriction-including-without-limitation-the-rights">in the Software without restriction, including without limitation the rights<br></h1>
<h1 id="to-use-copy-modify-merge-publish-distribute-sublicense-andor-sell">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br></h1>
<h1 id="copies-of-the-software-and-to-permit-persons-to-whom-the-software-is">copies of the Software, and to permit persons to whom the Software is<br></h1>
<h1 id="furnished-to-do-so-subject-to-the-following-conditions">furnished to do so, subject to the following conditions:<br></h1>
<h1 id="section-3"><br></h1>
<h1 id="the-above-copyright-notice-and-this-permission-notice-shall-be-included-in">The above copyright notice and this permission notice shall be included in<br></h1>
<h1 id="all-copies-or-substantial-portions-of-the-software.">all copies or substantial portions of the Software.<br></h1>
<h1 id="section-4"><br></h1>
<h1 id="the-software-is-provided-as-is-without-warranty-of-any-kind-express-or">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br></h1>
<h1 id="implied-including-but-not-limited-to-the-warranties-of-merchantability">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br></h1>
<h1 id="fitness-for-a-particular-purpose-and-noninfringement.-in-no-event-shall-the">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br></h1>
<h1 id="authors-or-copyright-holders-be-liable-for-any-claim-damages-or-other">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br></h1>
<h1 id="liability-whether-in-an-action-of-contract-tort-or-otherwise-arising-from">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br></h1>
<h1 id="out-of-or-in-connection-with-the-software-or-the-use-or-other-dealings-in">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br></h1>
<h1 id="the-software.">THE SOFTWARE.<br></h1>
<h1 id="section-5"><br></h1>
<p id="section-6"><br>
<br> Reaper and the Reaper-Logo are trademarks of Cockos inc and can be found at <a href="http://www.reaper.fm">reaper.fm</a><br> <br> The SWS-logo has been taken from the SWS-extension-project, which can be found at <a href="http://www.sws-extension.org">sws-extension.org</a><br> <br> Ultraschall-API written by Meo Mespotine<a href="http://www.mespotine.de">mespotine.de</a> with contributions from <a href="https://twitter.com/fernsehmuell">Udo Sauer</a> and <a href="https://twitter.com/rstockm">Ralf Stockmann</a><br> If you want to donate to our project, head over to <a href="http://www.ultraschall.fm/danke">ultraschall.fm/danke</a>.<br> <br> Kudos to lokasenna, who suggested some cool things, that made some functions much faster and sparkled new ones. Cheers!<br> <br>
</divl></table><br><hr><a id="Datatypes_Introduction"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Parameters and returnvalues are usually of specific types. Let's look at the following function:<br> <br> '''<br> integer number_of_items, array MediaItemArray, array MediaItemStateChunkArray = ultraschall.GetMediaItemsAtPosition(number position, string trackstring)<br> '''<br> <br> The returnvalues number_of_items is of type integer, MediaItemArray is of type array/type, MediaItemStateChunkArray if of type array.<br> The parameters position is of type number, trackstring is of type string.<br> These parameters/returnvalues only accept/return data of these given types.<br> <br> The Ultraschall-API uses a lot of the standard-datatypes provided by Lua and Reaper/SWS, which are:<br> Lua:<br> boolean - either true or false<br> integer - an integer number<br> number - a number, usually float but also accepts integers<br> string - a string of characters<br> table/array - a Lua-array<br> function - a function as an object<br> nil - the value &quot;nothing&quot;<br> Reaper:<br> ReaProject - a project/projecttab as an object<br> MediaTrack - a track as an object; has all attributes of a track, as solo/mute-state, name, MediaItems lying in this track, etc<br> MediaTrackStateChunk - a string containing an RPP-XML-description of all states/attributes of a MediaTrack<br> MediaItem - an item as an object; has all attributes of an item, as length, position, volume, etc<br> MediaItem_Take - a specific take of an item as an object; one item can have multiple takes<br> MediaItemStateChunk - a string containing an RPP-XML-description of all states/attributes of a MediaItem<br> TrackEnvelope - an envelope-lane as an object<br> EnvelopeStateChunk - a string containing an RPP-XML-description of all states/attributes of a TrackEnvelope<br> PCM_source - audio/video/image as an object; connects MediaItems to the actual media-file<br> <br> If a datatype has &quot;optional&quot; before it, this parameter/returnvalue is optional. That means, such parameters don't need to be given, such return-values can be nil.<br> <br> In addition to the already used datatypes, the Ultraschall-API introduces some more datatypes, like:<br> <a href="#Datatypes_trackstring">trackstrings</a> - some functions accept multiple tracks. Trackstrings are a string with all tracknumbers, separated by commas.<br> <a href="#Datatypes_MediaItemArray">MediaItemArray</a> - some functions accept multiple mediaitems. MediaItemArrays are tables containing MediaItem-objects. The index of the table is integers.<br> <a href="#Datatypes_MediaItemStateChunkArray">MediaItemStateChunkArray</a> - some functions accept multiple mediaitem-statechunks. MediaItemStateChunkArrays are tables containing MediaItemStateChunks. The index of the table is integers.<br> <a href="#Datatypes_EnvelopePointObject">EnvelopePointObject</a> - it's a table containing all attributes of an envelope-point, <br> like: parent TrackEnvelope-object, envelope-idx, time, value, shape, tension, selected, dBValue converted from value<br> <a href="#Datatypes_EnvelopePointArray">EnvelopePointArray</a> - it's a table with multiple EnvelopePointObjects in it, indexed by an integer<br> <br> These Ultraschall-API-specific datatypes are described in more detail in the following chapters.<br> <br>
</divl></table><br><hr><a id="Datatypes_trackstring"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Many functions allow you to process through multiple tracks. As good as this is, this provided some difficulty in telling a function, to which track it shall be applied to.<br> Hence the datatype: trackstring<br> <br> A trackstring is just a simple string with all tracknumbers that you want a certain function to be applied to.<br> Examplecode: <br> '''<br> trackstring = &quot;1,2,5,7,9&quot;<br> '''<br> <br> These tracknumbers must be separated from each other using a comma. Whitespaces are not allowed.<br> <br> With trackstrings, passing the wanted tracks to a function is really easy.<br> <br> You can create trackstrings using: <a href="#CreateTrackString">CreateTrackString</a>, <a href="#CreateAllTracksTrackString">CreateAllTracksTrackString</a>, <a href="#CreateTrackString_ArmedTracks">CreateTrackString_ArmedTracks</a>, <a href="#CreateTrackString_UnarmedTracks">CreateTrackString_UnarmedTracks</a>, <a href="#CreateTrackString_SelectedTracks">CreateTrackString_SelectedTracks</a>.<br> You can manipulate trackstrings using: <a href="#InverseTrackstring">InverseTrackstring</a>, <a href="#OnlyTracksInBothTrackstrings">OnlyTracksInBothTrackstrings</a>, <a href="#OnlyTracksInOneTrackstring">OnlyTracksInOneTrackstring</a>, <a href="#RemoveDuplicateTracksInTrackstring">RemoveDuplicateTracksInTrackstring</a>, <a href="#OnlyMediaItemsOfTracksInTrackstring">OnlyMediaItemsOfTracksInTrackstring</a>, <a href="#OnlyMediaItemsOfTracksInTrackstring_StateChunk">OnlyMediaItemsOfTracksInTrackstring_StateChunk</a><br> You can check for validate trackstrings using: <a href="#IsValidTrackString">IsValidTrackString</a><br> <br> Some of the functions who make use of trackstrings are: <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a>, <a href="#GetAllMediaItemsInTimeSelection">GetAllMediaItemsInTimeSelection</a>, <a href="#DeleteMediaItems_Position">DeleteMediaItems_Position</a>, <a href="#IsItemInTrack3">IsItemInTrack3</a>, and more<br> <br>
</divl></table><br><hr><a id="Datatypes_MediaItemArray"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Many functions allow you to process through multiple mediaitems. To be able to pass multiple mediaitems at once to a function, I added the datatype MediaItemArray.<br> <br> A MediaItemArray is an array with many MediaItems, indexed by an integer<br> Examplecode: <br> '''<br> -- get the MediaItems<br> MediaItem1=reaper.GetMediaItem(0,0)<br> MediaItem2=reaper.GetMediaItem(0,1)<br> MediaItem3=reaper.GetMediaItem(0,2)<br> MediaItem4=reaper.GetMediaItem(0,3)<br> <br> -- create and fill the MediaItemArray<br> MediaItemArray={}<br> MediaItemArray[1]=MediaItem1<br> MediaItemArray[2]=MediaItem2<br> MediaItemArray[3]=MediaItem3<br> MediaItemArray[4]=MediaItem4<br> '''<br> <br> MediaItemArrays will be read, until an index of the MediaItemArray is nil. In the above example, MediaItemArray[5] would be nil and therefore seen as the end of the array, even if there's a MediaItemArray[6]!<br> <br> With MediaItemArray, passing the wanted MediaItems to a function is really easy.<br> <br> You can create MediaItemArrays using: <a href="#GetAllMediaItems">GetAllMediaItems</a>, <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a>, <a href="#GetAllMediaItemsFromTrack">GetAllMediaItemsFromTrack</a>, <a href="#GetMediaItemsAtPosition">GetMediaItemsAtPosition</a>, <a href="#GetAllMediaItemsInTimeSelection">GetAllMediaItemsInTimeSelection</a>, etc<br> You can manipulate MediaItemArrays using: <a href="#ApplyActionToMediaItemArray">ApplyActionToMediaItemArray</a>, <a href="#ApplyFunctionToMediaItemArray">ApplyFunctionToMediaItemArray</a>, <a href="#InsertMediaItemArray">InsertMediaItemArray</a>, <a href="#ChangeDeltaLengthOfMediaItems_FromArray">ChangeDeltaLengthOfMediaItems_FromArray</a>, <a href="#ChangeDeltaOffsetOfMediaItems_FromArray">ChangeDeltaOffsetOfMediaItems_FromArray</a>, etc<br> You can check for validate MediaItemArrays using: <a href="#IsValidMediaItemArray">IsValidMediaItemArray</a><br> <br> Some of the functions who make use of MediaItemArray are: <a href="#DeleteMediaItemsFromArray">DeleteMediaItemsFromArray</a>, <a href="#DeselectMediaItems_MediaItemArray">DeselectMediaItems_MediaItemArray</a>, <a href="#GetAllLockedItemsFromMediaItemArray">GetAllLockedItemsFromMediaItemArray</a>, <a href="#InsertMediaItemArray">InsertMediaItemArray</a>, and more<br> <br>
</divl></table><br><hr><a id="Datatypes_MediaItemStateChunkArray"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Many functions allow you to process through multiple mediaitem-statechunks. To be able to pass multiple mediaitem-statechunks at once to a function, I added the datatype MediaItemStateChunkArray.<br> <br> A MediaItemStateChunkArray is an array with many MediaItemStateChunks, indexed by an integer<br> Examplecode: <br> '''<br> -- get the MediaItems<br> MediaItem1=reaper.GetMediaItem(0,0)<br> MediaItem2=reaper.GetMediaItem(0,1)<br> MediaItem3=reaper.GetMediaItem(0,2)<br> MediaItem4=reaper.GetMediaItem(0,3)<br> <br> -- get the MediaItemStateChunks<br> StateChunk1=reaper.GetItemStateChunk(MediaItem1, &quot;&quot;, false)<br> StateChunk2=reaper.GetItemStateChunk(MediaItem2, &quot;&quot;, false)<br> StateChunk3=reaper.GetItemStateChunk(MediaItem3, &quot;&quot;, false)<br> StateChunk4=reaper.GetItemStateChunk(MediaItem4, &quot;&quot;, false)<br> <br> -- create and fill the MediaItemStateChunkArray<br> MediaItemStateChunkArray={}<br> MediaItemStateChunkArray[1]=StateChunk1<br> MediaItemStateChunkArray[2]=StateChunk2<br> MediaItemStateChunkArray[3]=StateChunk3<br> MediaItemStateChunkArray[4]=StateChunk4<br> '''<br> <br> MediaItemStateChunkArrays will be read, until an index of the MediaItemStateChunkArray is nil. In the above example, MediaItemStateChunkArray[5] would be nil and therefore seen as the end of the array, even if there's a MediaItemStateChunkArray[6]!<br> <br> With MediaItemStateChunkArrays, passing the wanted MediaItemStateChunks to a function is really easy.<br> <br> You can create MediaItemStateChunkArrays using: <a href="#GetAllMediaItems">GetAllMediaItems</a>, <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a>, <a href="#GetAllMediaItemsFromTrack">GetAllMediaItemsFromTrack</a>, <a href="#GetMediaItemsAtPosition">GetMediaItemsAtPosition</a>, <a href="#GetAllMediaItemsInTimeSelection">GetAllMediaItemsInTimeSelection</a>, etc<br> You can manipulate MediaItemStateChunkArrays using: <a href="#AddLockStateTo_MediaItemStateChunkArray">AddLockStateTo_MediaItemStateChunkArray</a>, <a href="#ApplyStateChunkToItems">ApplyStateChunkToItems</a>, <a href="#OnlyMediaItemsOfTracksInTrackstring_StateChunk">OnlyMediaItemsOfTracksInTrackstring_StateChunk</a>, etc<br> You can check for validate MediaItemStateChunkArrays using: <a href="#IsValidMediaItemStateChunkArray">IsValidMediaItemStateChunkArray</a><br> <br> Some of the functions who make use of MediaItemStateChunkArrays are: <a href="#GetMediaItemStateChunkArrayLength">GetMediaItemStateChunkArrayLength</a>, <a href="#InsertMediaItemStateChunkArray">InsertMediaItemStateChunkArray</a>, <a href="#RippleInsert_MediaItemStateChunks">RippleInsert_MediaItemStateChunks</a>, <a href="#GetAllMediaItemsFromTrackStateChunk">GetAllMediaItemsFromTrackStateChunk</a> and more<br> <br>
</divl></table><br><hr><a id="Datatypes_EnvelopePointObject"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">When working with envelope-points, handling all the attributes such an envelope-point is quite unhandy. So I introduced the datatype EnvelopePointObject, containing all it's attributes.<br> <br> An EnvelopePointObject is an array with all attributes an envelope-point has.<br> Examplecode: <br> '''<br> MediaTrack=reaper.GetTrack(0,0) -- get MediaTrack<br> TrackEnvelope=reaper.GetTrackEnvelope(MediaTrack, 0) -- get TrackEnvelope<br> retval, EnvelopePointObject = ultraschall.CreateEnvelopePointObject(TrackEnvelope, 1, 20, 10, 0, 0, false) -- create EnvelopePointObject<br> '''<br> <br> An EnvelopePointObject is an array with all the attributes of an envelope-point, containing the following values:<br> EnvelopePointObject[1] - Trackenvelope; The TrackEnvelope-object, in which the point lies<br> EnvelopePointObject[2] - integer; Envelope-idx<br> EnvelopePointObject[3] - number; the time in seconds<br> EnvelopePointObject[4] - number; the raw value of the envelope-point<br> EnvelopePointObject[5] - integer; the shape of the envelope-point, with <br> 0 - Linear<br> 1 - Square<br> 2 - Slow start/end<br> 3 - Fast start<br> 4 - Fast end<br> 5 - Bezier<br> EnvelopePointObject[6] - number; tension of the envelope-point; -1 to 1; 0 for no tension<br> EnvelopePointObject[7] - boolean; if the envelope-point is selected(true) or not(false)<br> EnvelopePointObject[8] - number; dBValue converted from value<br> <br> EnvelopePointObjects make handling of envelope-points and it's attributes much easier.<br> <br> You can create EnvelopePointObjects using: <a href="#CreateEnvelopePointObject">CreateEnvelopePointObject</a>, <a href="#GetEnvelopePoint">GetEnvelopePoint</a>, etc<br> You can check for validate EnvelopePointObjects using: <a href="#IsValidEnvelopePointObject">IsValidEnvelopePointObject</a><br> <br> Some of the functions who make use of EnvelopePointObjects are: <a href="#AddEnvelopePoints_EnvelopePointObject">AddEnvelopePoints_EnvelopePointObject</a>, <a href="#SetEnvelopePoints_EnvelopePointObject">SetEnvelopePoints_EnvelopePointObject</a>, <a href="#DeleteEnvelopePoints_EnvelopePointObject">DeleteEnvelopePoints_EnvelopePointObject</a> and more<br> <br>
</divl></table><br><hr><a id="Datatypes_EnvelopePointArray"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">When working with multiple EnvelopePointObjects, I introduced the datatype EnvelopePointArray, containing multiple EnvelopePointObjects.<br> <br> An EnvelopePointArray is an array with multiple EnvelopePointObjects, indexed by an integer.<br> Examplecode: <br> '''<br> -- create EnvelopePointObjects<br> MediaTrack=reaper.GetTrack(0,0) -- get MediaTrack<br> TrackEnvelope=reaper.GetTrackEnvelope(MediaTrack, 0) -- get TrackEnvelope<br> retval, EnvelopePointObject1 = ultraschall.CreateEnvelopePointObject(TrackEnvelope, 1, 20, 10, 0, 0, false) -- create EnvelopePointObject1<br> retval, EnvelopePointObject2 = ultraschall.CreateEnvelopePointObject(TrackEnvelope, 1, 20, 10, 0, 0, false) -- create EnvelopePointObject2<br> retval, EnvelopePointObject3 = ultraschall.CreateEnvelopePointObject(TrackEnvelope, 1, 20, 10, 0, 0, false) -- create EnvelopePointObject3<br> <br> -- creating EnvelopePointArray<br> EnvelopePointArray={}<br> EnvelopePointArray[1]=EnvelopePointObject1<br> EnvelopePointArray[2]=EnvelopePointObject2<br> EnvelopePointArray[3]=EnvelopePointObject3<br> '''<br> <br> EnvelopePointArray makes passing multiple EnvelopePointObjects to functions much easier.<br> <br> You can create EnvelopePointArrays using: <a href="#GetEnvelopePointIDX_Between">GetEnvelopePointIDX_Between</a><br> You can check for validate EnvelopePointArrays using: <a href="#IsValidEnvelopePointArray">IsValidEnvelopePointArray</a><br> <br> Some of the functions who make use of EnvelopePointArrays are: <a href="#AddEnvelopePoints_EnvelopePointArray">AddEnvelopePoints_EnvelopePointArray</a>, <a href="#SetEnvelopePoints_EnvelopePointArray">SetEnvelopePoints_EnvelopePointArray</a>, <a href="#DeleteEnvelopePoints_EnvelopePointArray">DeleteEnvelopePoints_EnvelopePointArray</a> and more<br> <br>
</divl></table><br><hr><a id="Datatypes_CheckingDatatypes"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">When you work with data of different sources but need to work with data of a specific type, it would be handy to have ways of checking, whether a certain variable has data of a specific type.<br> Lua provides ways of checking for valid datatypes(type() and math.type()) as well as Reaper(ValidatePtr() and ValidatePtr2()).<br> <br> However, sometimes you want to have one function to check them all, and all these functions do not include Ultraschall-API-specific datatypes, so I added some stuff for that.<br> <br> 1) [type][#type]<br> works like Lua's own type-function, but checks for Reaper's own datatypes as well, like: <br> Lua: nil, number: integer, number: float, boolean, string, function, table, thread, userdata,<br> Reaper: ReaProject, MediaItem, MediaItem_Take, MediaTrack, TrackEnvelope, AudioAccessor, joystick_device, PCM_source<br> <br> userdata will be shown, if object isn't of any known type<br> <br> to get of which type a variable is, just use<br> <br> '''<br> datatype_of_variable = ultraschall.type(variable)<br> '''<br> <br> where the return-value datatype_of_variable will hold a string describing the type of the variable.<br> <br> Due some API-restrictions, SWS-specific datatypes are not (yet) supported.<br> <br> 2) Ultraschall-API specific or other Reaper-datatypes<br> To check for Ultraschall-API specific or other Reaper-datatypes, you can use the following functions:<br> <br> Ultraschall-API-specific:<br> <a href="#IsValidTrackString">IsValidTrackString</a> - checks, if a string is a valid <a href="#Datatypes_trackstring">trackstring</a><br> <a href="#IsValidMediaItemArray">IsValidMediaItemArray</a> - checks, if a table is a valid <a href="#Datatypes_MediaItemArray">MediaItemArray</a><br> <a href="#IsValidMediaItemStateChunkArray%5D%20-%20checks,%20if%20a%20table%20is%20a%20valid%20%5BMediaItemStateChunkArray%5D(#Datatypes_MediaItemStateChunkArray)%3Cbr%3E%20%5BIsValidEnvelopePointObject%5D(#IsValidEnvelopePointObject)%20-%20checks,%20if%20a%20table%20is%20a%20valid%20%5BEnvelopePointObject%5D(#Datatypes_EnvelopePointObject)%3Cbr%3E%20%5BIsValidEnvelopePointArray%5D(#IsValidEnvelopePointArray)%20-%20checks,%20if%20a%20table%20is%20a%20valid%20%5BEnvelopePointArray%5D(#Datatypes_EnvelopePointArray)%3Cbr%3E%20%5BIsValidArrangeviewSnapshot%5D(#IsValidArrangeviewSnapshot)%20-%20checks,%20if%20an%20extstate%20is%20a%20valid%20ArrangeviewSnapshot%3Cbr%3E%20%3Cbr%3E%20Other%20Reaper-datatypes:%3Cbr%3E%20%5BIsValidReaProject%5D(#IsValidReaProject)%20-%20checks,%20if%20an%20object%20is%20a%20valid%20ReaProject%3Cbr%3E%20%5BIsValidProjectStateChunk%5D(#IsValidProjectStateChunk)%20-%20checks,%20if%20a%20string%20is%20a%20valid%20ProjectStateChunk%3Cbr%3E%20%5BIsValidTrackStateChunk%5D(#IsValidTrackStateChunk)%20-%20checks,%20if%20a%20string%20is%20a%20valid%20TrackStateChunk%3Cbr%3E%20%5BIsValidMediaItemStateChunk%5D(#IsValidMediaItemStateChunk)%20-%20checks,%20if%20a%20string%20is%20a%20valid%20MediaItemStateChunk%3Cbr%3E%20%5BIsValidEnvStateChunk%5D(#IsValidEnvStateChunk)%20-%20checks,%20if%20a%20string%20is%20a%20valid%20EnvelopeStateChunk%3Cbr%3E%20%3Cbr%3E%20They%20will%20be%20part%20of%20ultraschall.type()%20someday.%3Cbr%3E%20%3Cbr%3E%203">IsValidMediaItemStateChunkArray</a> other types of data<br> These aren't datatypes, but you may want to check them for validity as well<br> <a href="#IsValidGuid">IsValidGuid</a> - checks, whether a string is a valid GUID<br> <a href="#IsValidMatchingPattern">IsValidMatchingPattern</a> - checks, whether a string is a valid matching pattern for Lua's pattern-matching<br> <br>
</divl></table><br><hr><a id="Introduction_API_Variables"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">When working with the Ultraschall-API or general programming in Reaper, some additional things may or may not be helpful to know, like:<br> <br> 1) <a href="#Script_Path">Script_Path</a> - which contains the current path to Reaper's-scripts-folder<br> 2) <a href="#Separator">Separator</a> - which contains the correct separator for paths; on Windows it is  on Mac and Linux it is /<br> 3) <a href="#StartTime">StartTime</a> - contains the starting time of the Ultraschall-API as used in the current script. That means, the starting time of the now running script.<br> 4) <a href="#Api_Path">Api_Path</a> - the current path to the Ultraschall-API folder.<br> 5) <a href="#Api_InstallPath">Api_InstallPath</a> - an API-variable that contains the path to the install-folder of the Ultraschall-API<br> <br> <br>
</divl></table><br><hr><a id="Rendering_01_Introduction"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">The Ultraschall-API provides functions for rendering your projects, without having to use the Rendering-dialog of Reaper.<br> This gives you a wide range of possibilities to customize your rendering-needs.<br> <br> Basically the process is based on:<br> 1) creating a renderstring with all format-specific-settings, using the accompanying functions:<br> <a href="#CreateRenderCFG_AIFF">CreateRenderCFG_AIFF</a>, <a href="#CreateRenderCFG_DDP">CreateRenderCFG_DDP</a>, <a href="#CreateRenderCFG_FLAC">CreateRenderCFG_FLAC</a>, <a href="#CreateRenderCFG_MP3ABR">CreateRenderCFG_MP3ABR</a>, <a href="#CreateRenderCFG_MP3CBR">CreateRenderCFG_MP3CBR</a>, <a href="#CreateRenderCFG_MP3MaxQuality">CreateRenderCFG_MP3MaxQuality</a>, <a href="#CreateRenderCFG_MP3VBR">CreateRenderCFG_MP3VBR</a>, <br> <a href="#CreateRenderCFG_OGG">CreateRenderCFG_OGG</a>, <a href="#CreateRenderCFG_Opus">CreateRenderCFG_Opus</a>, <a href="#CreateRenderCFG_Opus2">CreateRenderCFG_Opus2</a>, <a href="#CreateRenderCFG_WAV">CreateRenderCFG_WAV</a>, <a href="#CreateRenderCFG_WAVPACK">CreateRenderCFG_WAVPACK</a>, <a href="#CreateRenderCFG_WebMVideo">CreateRenderCFG_WebMVideo</a><br> <br> 2) passing the render-string to the Render-functions<br> <a href="#RenderProject_RenderCFG">RenderProject_RenderCFG</a>, <a href="#RenderProjectRegions_RenderCFG">RenderProjectRegions_RenderCFG</a><br> <br> So the following code should render the current project into an MP3 with a Constant Bitrate of 128kbps.<br> Note: to render the currently opened project, it must be saved first!<br> '''<br> -- create Render-string<br> render_cfg_string = ultraschall.CreateRenderCFG_MP3CBR(11, 2)<br> <br> -- Pass this Render-string to the rendering-function<br> retval = ultraschall.RenderProject_RenderCFG(nil, &quot;c:\exportfile.mp3&quot;, 0, -1, false, false, false, render_cfg_string)<br> '''<br> <br> Read the accompanying documentation-entries for <a href="#CreateRenderCFG_MP3CBR">CreateRenderCFG_MP3CBR</a> and <a href="#RenderProject_RenderCFG">RenderProject_RenderCFG</a> for more details and/or the following chapters.<br> <br>
</divl></table><br><hr><a id="Rendering_02_About_Renderstrings"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Render-strings(or render_cfg, as they are named in Reaper) are strings, that contain all settings for a specific Render-Output-format, as MP3, WAV, AIF, FLAC, etc.<br> They are usually stored into RPP-projectfiles and are quite cryptic(for those of you, who know what that means: BASE64-encoded).<br> These are essential for rendering a project using the provided rendering-functions, so the Ultraschall-API provides functions who create these render-strings.<br> <br> All these functions start with CreateRenderCFG_ in their name, so if you are looking for a specific format, use CreateRenderCFG_audioformat (like CreateRenderCFG_FLAC, etc). <br> The parameters of these functions represent all format-options as you are used from the Render-dialog. They should be fairly complete, though some formats (Video, OGG) are limited with some of their options(fps, width, height, kbps, etc).<br> This is due my approach decoding them, though I tried to provide all settings that are useful in your everyday use(documented in the accompanying parameter-descriptions in the functions-reference).<br> <br> Example for FLAC:<br> <br> '''<br> render_string = ultraschall.CreateRenderCFG_FLAC(integer BitDepth, integer EncSpeed)<br> '''<br> <br> creates the render-string for the FLAC-fileformat. Just provide the BitDepth(e.g 0 for 24 Bit) and the encoding-speed(EncSpeed) (e.g 5 for the default encoding speed). <br> Have a look into the functions-reference to get the possible values for these parameters.<br> <br> '''<br> render_string = ultraschall.CreateRenderCFG_FLAC(0, 5)<br> '''<br> <br> This will create a render-string for FLAC with 24bit-depth and the encoding-speed of 5(which is the default-setting in the render-dialog).<br> <br> This renderstring can then be passed over to <a href="#SetProject_RenderCFG">SetProject_RenderCFG</a> to set it into a project-file, or to <a href="#RenderProject_RenderCFG">RenderProject_RenderCFG</a> to render a projectfile using the format-settings in the Render-string.<br> <br> The following render-string-functions are available in Ultraschall-API<br> <a href="#CreateRenderCFG_AIFF">CreateRenderCFG_AIFF</a>, <a href="#CreateRenderCFG_DDP">CreateRenderCFG_DDP</a>, <a href="#CreateRenderCFG_FLAC">CreateRenderCFG_FLAC</a>, <a href="#CreateRenderCFG_MP3ABR">CreateRenderCFG_MP3ABR</a>, <a href="#CreateRenderCFG_MP3CBR">CreateRenderCFG_MP3CBR</a>, <a href="#CreateRenderCFG_MP3MaxQuality">CreateRenderCFG_MP3MaxQuality</a>, <a href="#CreateRenderCFG_MP3VBR">CreateRenderCFG_MP3VBR</a>, <br> <a href="#CreateRenderCFG_OGG">CreateRenderCFG_OGG</a>, <a href="#CreateRenderCFG_Opus">CreateRenderCFG_Opus</a>, <a href="#CreateRenderCFG_Opus2">CreateRenderCFG_Opus2</a>, <a href="#CreateRenderCFG_WAV">CreateRenderCFG_WAV</a>, <a href="#CreateRenderCFG_WAVPACK">CreateRenderCFG_WAVPACK</a>, <a href="#CreateRenderCFG_WebMVideo">CreateRenderCFG_WebMVideo</a> <br> <br>
</divl></table><br><hr><a id="Rendering_03_About_Renderingfunctions"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">The rendering-functions let you render a project, either a stored rpp-project-file or the currently opened one(only when it has been saved!).<br> They provide you with a wide range of functionality, so the rendering process should be quite close to Reaper's &quot;official&quot;-own-process using the render-dialog.<br> <br> There are currently two different render-functions available:<br> 1) <a href="#RenderProject_RenderCFG">RenderProject_RenderCFG</a> - with this one, you can render a whole project or just from startposition to endposition in seconds<br> 2) <a href="#RenderProjectRegions_RenderCFG">RenderProjectRegions_RenderCFG</a> with this one, you can render specific regions of a project<br> <br> Basically they are the same, with the only difference, that with the first one you can set a specific startposition and endposition, while the second one, you set it to a region-number.<br> That said, a lot of the parameters are the same.<br> projectfilename_with_path - the projectfile with path, that you want to render. Set it to nil, if you want to render the currently opened project(which must be saved before rendering!)<br> renderfilename_with_path - the filename with path of the output-file<br> overwrite_without_asking - if you want to overwrite already existing outputfiles, set this to true; else, set it to false<br> <br> The following two are directly connected to some of Reaper's dialogs:<br> renderclosewhendone - the render-progress-window, that is shown during the actual rendering can be closed automatically after rendering is finished(there's a checkbox in that window to set this).<br> set this to true to automatically close it; set it to false to keep it shown; set it to nil and it will use the setting the user set with the checkbox<br> filenameincrease - another of Reaper's dialogs, that will pop up, when an output-file already exists and overwrite_without_asking is set to false. It will ask you to automatically <br> increase the filename with a number to prevent accidental overwriting.<br> Set this to true to automatically increase filename; set it to false to show the dialog; set it to nil to use the settings the user chose<br> <br> The last parameter is the place for your render-string:<br> rendercfg - the renderstring, as created using a CreateRenderCFG_XXX-function, as described in <a href="#Rendering_02_About_Renderstrings">Rendering_02_About_Renderstrings</a>.<br> <br> With that, you should be able to successfully render your project.<br> <br> For more enhanced customization of Rendering, see <a href="#Rendering_04_Change_more_render_settings">Rendering_04_Change_more_render_settings</a> for more details.<br> <br>
</divl></table><br><hr><a id="Rendering_04_Change_more_render_settings"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Reaper's own render-dialog provides you with much more possibilities, than the rendering-functions themselves provide you with.<br> <br> In the likely case, that you want to influence more things for rendering, like samplerate, stereo or mono, etc, you should do the following things:<br> <br> 1) make a copy of the rpp-file that you want to render using <a href="#MakeCopyOfFile">MakeCopyOfFile</a>. The copy must have a different name and be in the same folder, as the original rpp-file!<br> 2) Now you can alter the copy of the projectfile using the following Ultraschall-Framework-functions, that represent certain elements from Reaper's Render-Dialog:<br> - <a href="#SetProject_RenderFilename">SetProject_RenderFilename</a> - to alter the output-filename<br> - <a href="#SetProject_RenderPattern">SetProject_RenderPattern</a> - to set the wildcards for the output-filename <br> - <a href="#SetProject_RenderDitherState">SetProject_RenderDitherState</a> - to set the &quot;Master mix: Dither/Noise shaping&quot;-checkboxes<br> - <a href="#SetProject_RenderFreqNChans">SetProject_RenderFreqNChans</a> - to set the Sample rate in Hz and Channels<br> - <a href="#SetProject_RenderRange">SetProject_RenderRange</a> - to set Bounds-dropdownlist, Time bounds-entryboxes and Tail<br> - <a href="#SetProject_RenderResample">SetProject_RenderResample</a> - to set &quot;Resample mode (if needed)&quot; <br> - <a href="#SetProject_RenderSpeed">SetProject_RenderSpeed</a> to set the render-speed, and<br> - <a href="#SetProject_RenderStems">SetProject_RenderStems</a> to set, whether to render stems, Master mix, region-render-matrix, etc (Source-dropdownlist)<br> <br> 3) after you've set the individual render-settings, you create a render-string, as described in <a href="#Rendering_02_About_Renderstrings">Rendering_02_About_Renderstrings</a>.<br> 4) render using the altered copy(!) of the projectfile(not the original projectfile!), as described in <a href="#Rendering_03_About_Renderingfunctions">Rendering_03_About_Renderingfunctions</a>.<br> <br> <br> If you want to alter the currently opened project, you need to save it first. After that, use:<br> <br> '''<br> retval, projectfilename_with_path = reaper.EnumProjects(-1,&quot;&quot;)<br> '''<br> <br> to get the projectfilename_with_path of the current project as returnvalue. Use projectfilename_with_path and go through steps 1 through 4.<br> <br> The functions in step 2) are just a small selection of the functions to alter project-files, as provided by the Ultraschall-API. Browse through the functions in the &quot;Project-Files&quot;-section of the index of the Ultraschall-API-Functions-Reference for many more of them.<br> <br>
</divl></table><br><hr><a id="Arrangeview_Snapshots_Introduction"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">When working with big or complex projects, <br> <br> Sometimes it's a good thing to have quick access to certain parts of the project, certain view-settings, zoom-factors. Arrangeview-snapshots are meant to help with that.<br> <br> Arrangeview-Snapshots are snapshots that store the current position of the arrangeview as well as it's zoom-factor. You can decide, whether to store only the zoom-factor or the position. You can also give a short description to a ArrangeView-Snapshot, so you can store, what to expect from a certain snapshot.<br> They can be retrieved and the arrange-view can be set to these settings. That way, quick navigation through often accessed parts of the project is fast and easy.<br> <br> Arrangeview-Snapshots are stored as ProjExtStates, which means, that the settings are stored in the project itself and can be retrieved the next time the project is loaded.<br> <br> Due limitations with Reaper's own API, storing the vertical-scroll-position of the arrangeview isn't possible yet. This will change as soon as the limitation is raised from Reaper's own API.<br> <br>
</divl></table><br><hr><a id="Arrangeview_Snapshots_HowToStoreRetrieveDelete"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">If you want to store the current position and zoom-factor of the Arrangeview, you can use the function <a href="#StoreArrangeviewSnapshot">StoreArrangeviewSnapshot</a>.<br> <br> It accepts the following parameters:<br> slot - the slot for the snapshot, which must be an integer. The function will overwrite an already existing snapshot. To prevent that,<br> use <a href="#IsValidArrangeviewSnapshot">IsValidArrangeviewSnapshot</a> to check, if it's already existing.<br> description - a short description, what the snapshot contains so you know, what to expect from it<br> position - set to true to store the startposition and endposition of the arrangeview. Otherwise(false), it will only store the current horizontal zoom-factor<br> vzoom - set to true, if you want to store the vertical zoom-factor as well; set to false, if you don't want it to be stored.<br> <br> If you want to retrieve the settings of a certain Arrange-View-Snapshot, you can use <a href="#RetrieveArrangeviewSnapshot">RetrieveArrangeviewSnapshot</a>, which will<br> return all settings from an Arrangeview-snapshot. The return-values of RetrieveArrangeviewSnapshot basically work the same as the parameters of StoreArrangeviewSnapshot.<br> <br> If you want to check, whether a slot is already used, you can use <a href="#IsValidArrangeviewSnapshot">IsValidArrangeviewSnapshot</a>, which will return true in that case and false, if the slot is unused.<br> <br> To delete a certain slot, just use <a href="#DeleteArrangeviewSnapshot">DeleteArrangeviewSnapshot</a>.<br> <br>
</divl></table><br><hr><a id="Arrangeview_Snapshots_HowToRestore"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">When having stored an Arrangeview-Snapshot into a slot, you certainly want to restore it at one point. For that, use <a href="#RestoreArrangeviewSnapshot">RestoreArrangeviewSnapshot</a>.<br> <br> This function let's you restore an earlier arrange-view completely, but also allows you to individually set, what you want to restore, using the parameters:<br> slot - is the Arrangeview-Snapshot you want to restore<br> <br> the other parameters are optional, means, if you omit them or set them to nil, they will restore the setting from the snapshot or use a default setting<br> position - true, restore the start and endposition of the arrange-view; false, just restore the horizontal-zoom-factor<br> vzoom - set to true to restore the vertical zoom-factor or set to false to keep the current one<br> hcentermode - this decides, what shall be in the center of the arrangeview, when position is set to false, with several options possible:<br> nil, keeps center of view in the center during zoom(default setting)<br> -1, default selection, as set in the reaper-prefs, <br> 0, edit-cursor or playcursor(if it's in the current zoomfactor of the view during playback/recording) in center,<br> 1, keeps edit-cursor in center of zoom<br> 2, keeps center of view in the center during zoom<br> 3, keeps in center of zoom, what is beneath the mousecursor<br> <br> This should give you full control in what to restore from an Arrangeview-Snapshot and what to ignore.<br> <br>
</divl></table><br><hr><a id="Navigation_Introduction"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">When editing and postproducing a project, navigating through it is essential. For that, I added some functions that are not part of Reaper's own API, to help navigation, with functions for:<br> <br> 1) more control about moving the playcursor and the editcursor<br> 2) jumping to the next/previous closest marker/regionedge/itemedge<br> 3) centering the view to several possible center-positions selectable(mousecursor, editcursor, playcursor)<br> 4) Followmode, aka autoscrolling<br> <br> This should give you more control about programming faster and quicker navigation-capabilities.<br> <br>
</divl></table><br><hr><a id="Navigation_MovePlay_and_Editcursor"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">The Ultraschall-API provides you with many functions regarding changing the position of the playcursor and the editcursor.<br> For that we have numerous functions:<br> Editcursor only:<br> <a href="#JumpForwardBy">JumpForwardBy</a> - jumps forward editcursor by as many seconds you like; optionally you can move the playcursor as well to the new position.<br> <a href="#JumpBackwardBy">JumpBackwardBy</a> - jumps backward editcursor by as many seconds you like; optionally you can move the playcursor as well to the new position.<br> <br> Playcursor only:<br> <a href="#SetPlayCursor_WhenPlaying">SetPlayCursor_WhenPlaying</a> - sets the playcursor to a new position, during playing<br> <a href="#JumpForwardBy_Recording">JumpForwardBy_Recording</a> - stops recording, jumps forward a given amount of seconds and resumes recording<br> <a href="#JumpBackwardBy_Recording">JumpBackwardBy_Recording</a> - stops recording, jumps backward a given amount of seconds and resumes recording<br> <br> Both:<br> <a href="#SetPlayAndEditCursor_WhenPlaying">SetPlayAndEditCursor_WhenPlaying</a> - sets play and editcursor to position during playback<br> <br>
</divl></table><br><hr><a id="Navigation_GotoMarkersRegionItemEdges"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Markers and items provide you with much additional helpful information regarding the project. They also provide you with an additional information: useful positions to navigate through.<br> To make use of that, I added some functions for that:<br> 1) <a href="#GetClosestPreviousMarker">GetClosestPreviousMarker</a>, <a href="#GetClosestNextMarker">GetClosestNextMarker</a> - Get the previous/next closest marker at a given position<br> 2) <a href="#GetClosestPreviousRegionEdge">GetClosestPreviousRegionEdge</a>, <a href="#GetClosestNextRegionEdge">GetClosestNextRegionEdge</a> - Get the previous/next closest regionedge at a given position<br> 3) <a href="#GetPreviousClosestItemEdge">GetPreviousClosestItemEdge</a>, <a href="#GetNextClosestItemEdge">GetNextClosestItemEdge</a> - Get the previous/next closest itemedge at a given position<br> 4) <a href="#GetClosestGoToPoints">GetClosestGoToPoints</a> - get previous/next markers/regionedges/itemedges/projectstart/projectend from position, for those who need the full marker/region/item-position-package<br> <br> Let's go into more detail, by examining <a href="#GetClosestPreviousRegionEdge">GetClosestPreviousRegionEdge</a>.<br> <br> '''<br> number markerindex, number position, string markername, string edge_type = ultraschall.GetClosestPreviousRegionEdge(integer cursor_type, optional number time_position)<br> '''<br> <br> This function allows you to get, which is the previous closest region-edge-position(either the start or the end of a region) as seen from a given position. To set that position, you need to set the parameter cursor_type:<br> 0 - Edit Cursor, <br> 1 - Play Cursor, <br> 2 - Mouse Cursor, or<br> 3 - Timeposition<br> <br> If you set it to 3, you can use the optional parameter time_position, with which you can set any position, at which you want to know the previous closest region-edge.<br> <br> If you run that function, it will return the markerindex, which is the index of all markers in your project, the position at which the regionedge is located, the markername and the type of the edge, which is either &quot;beg&quot; or &quot;end&quot;.<br> <br> The Marker-functions (from 1) ) work the same, the Item-edge-functions (from 3) ) however have an additional parameter trackstring, with which you can set, from which tracks you want to get the next/previous closest item-edge-position.<br> <br> <br> The function <a href="#GetClosestGoToPoints">GetClosestGoToPoints</a> is the combination of all of these functions, which let's you decide fully, which edges/positions you want to check for. <br> It will also check, if the next/previous closest edge is the beginning or the end of the project.<br> <br>
</divl></table><br><hr><a id="Navigation_CenterView"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Sometimes it's a good idea to center the arrangeview to a certain point, may it be different points of interests within your project or just to get back to the playcursor/editcursor out of the view.<br> <br> For that, I added the function <a href="#CenterViewToCursor">CenterViewToCursor</a>.<br> Let's have a look at it:<br> <br> '''<br> ultraschall.CenterViewToCursor(integer cursortype, optional number position) <br> '''<br> <br> It has two parameters, of which cursortype allows you to give the type of the cursor to center around:<br> 1 - change arrangeview with edit-cursor centered<br> 2 - change arrangeview with play-cursor centered<br> 3 - change arrangeview with mouse-cursor-position centered<br> 4 - centers arrangeview around the position given with parameter position<br> <br> The second parameter position is an optional one and only used, if cursortype is set to 4. It allows you to give a specific position in seconds, which the arrangeview shall be centered around.<br> <br> This functions only centers the given position/cursor-position to the arrangeview. It keeps the zoom-factor intact.<br> <br>
</divl></table><br><hr><a id="Navigation_Autoscroll_Followmode"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Reaper allows you to set autoscrolling during playback/recording. It allows you to set it to continuous scrolling or to &quot;page-wise&quot;-scrolling.<br> This is quite flexible but hidden somewhat within the actions of Reaper. So I added the function <a href="#ToggleScrollingDuringPlayback">ToggleScrollingDuringPlayback</a>.<br> It turns on autoscrolling for playback and recording AND continuous scrolling.<br> Let's have a look at it:<br> <br> '''<br> ultraschall.ToggleScrollingDuringPlayback(integer scrolling_switch, boolean move_editcursor, boolean goto_playcursor)<br> '''<br> <br> The parameter scrollin_switch allows you to turn on/off autoscrolling completely, that means, it will turn on autoscroll for playback and recording AND it sets autoscrolling to continuous scrolling.<br> The parameter move_edit_cursor allows you to set, if the editcursor shall be moved to the current playposition. This has an effect only, if scrolling_switch is set to 1(off).<br> The last parameter goto_playcursor allows you to change the view to the current playcursor-position, if you turn on autoscrolling. This has an effect only, if scrolling_switch is set to 0(off).<br> <br> When running the function, it changes, if neccessary, the toggle-states of the actions 41817(View: Continuous scrolling during playback), 40036(View: Toggle auto-view-scroll during playback) and <br> 40262(View: Toggle auto-view-scroll while recording), which means, it sets if a certain autoscrolling behavior is turned on or not.<br> If you have your own custom actions toggling these actions, you probably shouldn't use this function. Otherwise it probably messes up your workflows.<br> <br>
</divl></table><br><hr><a id="GetSetStates_Project_Track_Item_Env_Introduction"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">One of the long-term-goals of the Ultraschall-API is full access to all states within projects, tracks, items, envelopes, including all states only available in StateChunks.<br> As of the current version, all track-states and many project and item-states are get and settable.<br> <br> The functions all work after the same principle, with the first parameter being the object to get/set the state from/to (Projectfile, MediaItem-object, MediaTrack-object, TrackEnvelope-Object).<br> The last parameter, which is an optional one, can be a StateChunk-representation of the object, like ProjectStateChunk, MediaItemStateChunk, TrackStateChunk, TrackEnvelopeStateChunk. This optional parameter will only be seen, when the first parameter(for the object) is set to nil.<br> That way, you can decide, whether to use the original-object or the StateChunk, whatever works better for you.<br> In Setting-State-functions, it is basically the same: the first parameter the object and the last parameter is the optional StateChunk(when the first parameter is set to nil). The parameters inbetween set the individual settings for that state.<br> <br> Let's have a look at two example functions <a href="#GetProject_CursorPos">GetProject_CursorPos</a> and <a href="#SetProject_CursorPos">SetProject_CursorPos</a>:<br> Get Project-State:<br> '''<br> number cursorpos = ultraschall.GetProject_CursorPos(string projectfilename_with_path, optional string ProjectStateChunk) <br> '''<br> <br> The first parameter is the filename with path to the RPP-Projectfile. When this is set to nil, you can pass a ProjectStateChunk(which is basically the content of the RPP-projectfile).<br> <br> Set Project-State:<br> '''<br> integer retval = ultraschall.SetProject_CursorPos(string projectfilename_with_path, number cursorpos, optional string ProjectStateChunk) <br> '''<br> <br> The first parameter is the filename with path to the RPP-Projectfile. When this is set to nil, you can pass a ProjectStateChunk(which is basically the content of the RPP-projectfile).<br> The parameter in the middle, cursorpos, can be set by you. That way, the cursorposition of the Project/ProjectStateChunk can be set to the position you prefer.<br> <br> The same principle is for MediaTrack-states and MediaItem-states:<br> ''' <br> -- the first parameter either MediaItem or nil, the last parameter can be a MediaItemStateChunk when first parameter is nil<br> number length = ultraschall.GetItemLength(MediaItem MediaItem, optional string MediaItemStateChunk)<br> string MediaItemStateChunk = ultraschall.SetItemLength(MediaItem MediaItem, integer length, string MediaItemStateChunk)<br> <br> -- the first parameter either MediaTrack or nil, the last parameter can be a TrackStateChunk when first parameter is nil<br> integer lockedstate = ultraschall.GetTrackLockState(integer tracknumber, optional string TrackStateChunk)<br> boolean retval, string TrackStateChunk = ultraschall.SetTrackLockState(integer tracknumber, integer LockedState, optional string TrackStateChunk) <br> '''<br> <br> StateChunks can be gotten using reaper.GetTrackStateChunk(), reaper.SetTrackStateChunk(), reaper.GetItemStateChunk(), reaper.SetItemStateChunk(), reaper.GetEnvelopeStateChunk(), reaper.SetEnvelopeStateChunk().<br> To get ProjectStateChunks, you need to read the rpp-file, as currently there's no Get/SetProjectStateChunk-function in Reaper's own API.<br> <br>
</divl></table><br><hr><a id="Getting_Manipulating_Items_Introduction"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">When working with MediaItems, it often was frustrating for me to code, how to get their MediaItem-objects. Especially when &quot;mass-working&quot; with dozens and more MediaItems.<br> So I wrote a set of functions to work with MediaItems more comfortably.<br> <br> These functions include getting MediaItem-objects by time AND track, <a href="#GetSetStates_Project_Track_Item_Env_Introduction">getting MediaItem-states</a>, editing, inserting, manipulating, spectral edit, previewing, RippleCut, RippleInsert, SectionCut, working with locked, selected items, applying Reaper-actions to MediaItems, etc.<br> <br> When working with masses of MediaItems, I either use the datatypes <a href="#Datatypes_MediaItemArray">MediaItemArrays</a> or <a href="#Datatypes_MediaItemStateChunkArrays">MediaItemStateChunkArrays</a>.<br> When passing over the tracks wanted, I use the datatype <a href="#Datatypes_trackstring">trackstrings</a>.<br> <br> All this stuff should help you getting and manipulating MediaItems much more easier.<br> <br> Let's begin with getting items by time(range) and tracks.<br> <br>
</divl></table><br><hr><a id="Getting_Manipulating_Items_GetMediaItems"></a>
<p><u>Functioncall:</u><div style="padding-left:4%;font-size:100%"></div><p>
<u>Description:</u><br><divl style="padding-left:4%;">Let's face it, when editing items of a project in Reaper, you either click on the items or select them in a 2D-way, by drawing a boundary box around the items of your choice or using a time-selection.<br> What you do by that is selecting the items by time. What you also do is, selecting the items by track, as your boundary box may go over several tracks. Or you use a track-selection by clicking on the tracks you want.<br> In either way, you select them in a 2Dimensional way.<br> Not with Reaper's own API. Sure, you can somehow choose the MediaItems by track or by project, but you can't select by multiple tracks. And certainly not by a time-range.<br> <br> This was annoying for me, so I wrote two functions(my favorite ones in this api, I have to admit ;) ) that address this: <a href="#GetMediaItemsAtPosition">GetMediaItemsAtPosition</a> and <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a>.<br> Let's have a closer look at them.<br> <a href="#GetMediaItemsAtPosition">GetMediaItemsAtPosition</a>:<br> <br> '''<br> integer number_of_items, array MediaItemArray, array MediaItemStateChunkArray = ultraschall.GetMediaItemsAtPosition(number position, string trackstring)<br> '''<br> <br> This function gives you all items at position passed with parameter position and within the tracks given by parameter trackstring.<br> It returns the number of items, an array with all MediaItems and an array with all StateChunks of the MediaItems returned.<br> With this function, you can easily get the items from a certain position, without having to deal with looking into the MediaItem-objects for the correct time-position, or even have to care, where to get the corresponding tracks from an item.<br> This function does this for you.<br> <br> But what, if you want to get the MediaItems inbetween a startingposition and an endposition?<br> For this, I wrote the function <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a>:<br> <br> '''<br> integer count, array MediaItemArray, array MediaItemStateChunkArray = ultraschall.GetAllMediaItemsBetween(number startposition, number endposition, string trackstring, boolean inside) <br> '''<br> <br> which basically returns the same things, as GetMediaItemsAtPosition. The difference lies in the parameters.<br> You can pass a startposition and an endposition(which must be bigger than or equal startposition), <a href="#Datatypes_trackstring">trackstrings</a>, which is a string with all tracks, separated by commas and the parameter inside.<br> When you set inside to true, it will return only items that are completely within startposition and endposition. When setting inside to false, it will also return items, that are partially within start- and endposition, like items beginning before startposition or ending after endposition.<br> <br> With these two functions, getting items is much, much easier than before.<br> <br> In addition to them, I also added some more functions for getting MediaItems, namely:<br> <a href="#GetAllMediaItems">GetAllMediaItems</a> - get all MediaItems from the project into a handy MediaItemArray, for further &quot;mass-manipulation&quot; of them.<br> <a href="#GetAllLockedItemsFromMediaItemArray">GetAllLockedItemsFromMediaItemArray</a> - get all MediaItems that are locked, from a MediaItemArray<br> <a href="#GetAllMediaItemsFromTrack">GetAllMediaItemsFromTrack</a> - get all MediaItems from a track, returned as MediaItemArray<br> <a href="#GetAllMediaItemsInTimeSelection">GetAllMediaItemsInTimeSelection</a> - get all MediaItems in given tracks from the current time-selection<br> <br>
</divl></table><br><br><hr><table width="100%"><td style="position:absolute; right:0;">Automatically generated by Ultraschall-API 4.00 Beta 2.7 - 28 functions available</td></table><br><hr></div></body></html>