<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<USDocML>
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Introduction_001_Api</slug>
        <title>Introduction to the Ultraschall API</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
                The Ultraschall-Extension is intended to be an extension for the DAW Reaper, that enhances it with podcast functionalities. Most DAWs are intended to be used by musicians, for music, but podcasters have their own needs to be fulfilled. In fact, in some places their needs differ from the needs of a musician heavily. Ultraschall is intended to optimise the Reaper's workflows, by reworking them with functionalities for the special needs of podcasters.
                
                The Ultraschall-Framework itself is intended to include a set of Lua-functions, that help creating such functionalities. By giving programmers helper functions to get access to each and every corner of Reaper. That way, extending Ultraschall and Reaper is more comfortable to do.
                
                This API was to be used within Ultraschall only, but quickly evolved into a huge 700 function-library, that many 3rd-party programmers and scripters may find use in, with many useful features, like:
               
                   - Rendering - you can render your projects without having to use the render-dialog. You can customize the rendering-workflow in every way you want.
                                   just create a renderstring and pass it over to [RenderProject_RenderCFG](usdocml://RenderProject_RenderCFG) or [RenderProjectRegions_RenderCFG](usdocml://RenderProjectRegions_RenderCFG)
                   - Navigation, Follow and Arrangeview-Manipulation - get/set cursors, zoom, autoscroll-management, scroll, etc
                   - ArrangeView-Snapshots - you can save, retrieve snapshots of the arrangeview, including position, zoomstates to quickly jump through parts of your project
                   - Trackstates - you can access and set all(!) track-states available
                   - Mediaitem-states - you can access and set many mediaitem-states (more will follow)
                   - ItemExtStates/TrackExtStates - you can save additional metadata easily for specific tracks and items using ItemExtStates and TrackExtStates
                   - File access - many helperfunctions for reading, writing, copying files. No more hassle writing it yourself!
                       e.g [ReadFullFile](usdocml://ReadFullFile), [WriteValueToFile](usdocml://WriteValueToFile), etc
                   - Cough-Mute-management - you can write your own cough-buttons, that set the state of the mute-envelope of a track easily
                   - Marker - extensive set of marker functions, get, set, export, import, enumerate, etc
                   - Spectrogram - you can program the spectrogram-view
                   - Get MediaItems - you can get all media-items within a time-range AND within the tracks you prefer; a 2D-approach
                       e.g. [GetAllMediaItemsBetween](usdocml://GetAllMediaItemsBetween) and [GetMediaItemsAtPosition ](usdocml://GetMediaItemsAtPosition ), etc
                   - Gaps between items - you can get the gaps between items in a track, using [GetGapsBetweenItems](usdocml://GetGapsBetweenItems)
                   - Edit item(s) - Split, Cut, Copy, Paste, Move, RippleCut, RippleInsert, SectionCut by tracks AND time/start to endposition
                       e.g. [RippleCut](usdocml://RippleCut), [RippleInsert](RippleInsert), [SectionCut](usdocml://SectionCut), [SplitMediaItems_Position](usdocml://SplitMediaItems_Position), [MoveMediaItemsBefore_By](usdocml://MoveMediaItemsBefore_By), [MoveMediaItemsSectionTo](usdocml://MoveMediaItemsSectionTo) and many more
                   - Previewing MediaItems and files - you can preview MediaItems and files without having to start playback of a project
                   - KB-Ini-Management - manipulate the reaper-kb.ini-file with custom-settings
                   - Checking for Datatypes - check all datatypes introduced with Ultraschall-API and all Lua/Reaper-datatypes
                   - UndoManagement - functions for easily making undoing of functions as well as preventing creating an undo-point
                   - RunCommand for Items/Tracks - apply actions to specific items/tracks
                   - Checking for changed projecttabs - check, if projecttabs have been added/removed
                   - ExtState-Management - an extensive set of functions for working with extstates as well as ini-files
                   - Data Manipulation- manipulate a lot of your data, including bitwise-integers, tables, etc
                   - Clipboard-Management - get items from clipboard
                   - Error Messaging System - all functions create useful error-messages that can be shown using, eg: [ShowLastErrorMessage](usdocml://ShowLastErrorMessage), for easier debugging
                   - tons of other helper-functions AND
                
                   - it's documented with this documentation. :D
                
                   Happy coding and let's see, what you can do with it :D
                    
                   Meo Mespotine (mespotine.de)
                
                For more information about Ultraschall itself, see [ultraschall.fm](http://www.ultraschall.fm) and if you want to support us, see [ultraschall.fm/danke](http://www.ultraschall.fm/danke) for donating to us.
                
                PS: In this documentation, I assume you have some basic knowledge in Lua and in using Reaper's own API-functions. Explaining both of these is beyond the scope of this doc.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Introduction
        </chapter_context>
        <previous_chapter></previous_chapter>
        <next_chapter>Introduction_002_How_to_Use</next_chapter>
        <tags>documentation, introduction, ultraschall-api</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Introduction_002_How_to_Use</slug>
        <title>How to use the Ultraschall API</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Using the Ultraschall-API is quite easy.
            
            First make sure, you use the right versions of Reaper and SWS:
               Reaper 5.95, SWS 2.9.7 and Julian Sader's plugin 0.951.
            You can download them at [reaper.fm](http://www.reaper.fm) and [sws-extension.org](http://www.sws-extension.org) respectively.
            Julian Sader's plugin can be installed using ReaPack.
            
            To install the Ultraschall-API:
            1. Just download the zip-file of the current version from [api.ultraschall.fm](http://api.ultraschall.fm).
            2. Extract it to the UserPlugins-folder in the Resources-folder of Reaper. You can find the correct Resources-path in the Reaper-menu "Options -> Show REAPER resource path in explorer/finder...".  
               The folder UserPlugins should contain the folder ultraschall_api and the files ultraschall_api_readme.txt and ultraschall_api.lua after this step.
            3. Now create a new script, by opening the Actions-window (Menu: Actions -> Show action list) and clicking the New-button next to "ReaScript:", give it a name and hit save.  
                    Include the following line in your script at the beginning: 
               
                        dofile(reaper.GetResourcePath().."/UserPlugins/ultraschall_api.lua")
               
                   Now you can program with the Ultraschall-API. Just add the functions AFTER the dofile-line.
            
            4. To test, if it's successfully installed, add 
                
                        ultraschall.ApiTest()
                
                   after the dofile-line and hit ctrl+s or cmd+s(on mac).
                
                   The script should show a messagebox, that tells you, which of the Ultraschall-API-parts are activated. If it shows, everything works fine :)
            
            If you are already familiar with programming Reaper's own API-functions, you know, that all of Reaper's functions are placed in a table called "reaper."  
                e.g. reaper.ShowConsoleMsg("msg")
                
            The Ultraschall-API is quite the same, but is using the table "ultraschall." instead.  
                e.g. ultraschall.ApiTest()
            
            
            Some functions need background-scripts be run first. Refer the [Introdution to background-scripts](#Background_Scripts_001_Introduction) for information about that.
            
            See the functions-reference for all available functions or read on in this documentation for a collection of concepts introduced by the Ultraschall-API.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Introduction
        </chapter_context>
        <previous_chapter>Introduction_001_Api</previous_chapter>
        <next_chapter>Introduction_003_How_to_Use_Beta_Functions_And_Hotfixes</next_chapter>
        <tags>documentation, introduction, how to use</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Introduction_003_How_to_Use_Beta_Functions_And_Hotfixes</slug>
        <title>How to use Beta functions and hotfixes</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Before a new version of the Ultraschall-API is finished, it is in beta-stage. But sometimes, bugs need to be fixed even before a new release is done or you may want to test new functions from the next release for bugs and quirks.  
            So I added two ways to deal with that.
            
            1. Hotfixes  
                   Hotfixes are available at [api.ultraschall.fm](http://api.ultraschall.fm). They provide fixes for functions and bugs that came across after a release, but no new functions.  
                   Just download the ultraschall\_hotfixes.lua and put it into UserPlugins/ultraschall\_api-folder.  
                   The chance is high, that there is already an ultraschall\_hotfixes.lua-file in the folder. You can safely overwrite it.  
                   Voila, you have added the most recent bugfixes.  
                     
                   To get the bugs back, just delete the ultraschall_hotfixes.lua.
                   
                   All fixes in ultraschall\_hotfixes.lua will be part of the next full version of the Ultraschall-API.
                   
                   Check again from time to time to get the latest hotfixes.
                
             2. Beta-functions and features
                Beta-functions are functions intended for a future release of the Ultraschall-API. If you want to test them, just download the latest Beta-Pack from [api.ultraschall.fm](http://api.ultraschall.fm).  
                Extract the files in the Beta-pack to UserPlugins of the Resources-folder of your Reaper-installation. Voila, the beta-functions are installed.  
                 
                To use them, you need to explicitly turn them on in your script, using the following lines:
                 
                 
                         ultraschall.US_BetaFunctions="ON"          -- Only has an effect, if ultraschall-beta-functions exist in Scripts-folder  
                                                                    -- Turn ON, if you want BETA-Api-Functions
                 
                 
                The documentation for beta-versions can be found at [api.ultraschall.fm/US_Beta.html](http://api.ultraschall.fm/US_Beta.html)
                 
                Be aware, they are in beta-stage. They will probably change, disappear or be exchanged with better functions. Beta-functions are only for testing purposes, not for productive coding!
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Introduction
        </chapter_context>
        <previous_chapter>Introduction02_How_to_Use</previous_chapter>
        <next_chapter>Introduction_004_Bugreporting_FeatureRequests</next_chapter>
        <tags>documentation, introduction, beta, hotfixes</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Introduction_004_Bugreporting_FeatureRequests</slug>
        <title>Introduction: Bugreporting and Feature Requests</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            If you find any bugs or itches and want to report them, I suggest you the following procedure:
            
               1. Make notes of: what operating-system you use(Mac, Win, Linux), which Reaper-version, which SWS-Version and which Ultraschall-Framework-Version.
               2. Write down, what you wanted to do, what you expected to happen and what has happened instead. Make it as detailed as possible(a code-fragment that triggers a bug, a screenvideo i.e. would be perfect), as more information helps to find out, where the problem lies. It's always better to write too much, than the other way around.
               Please keep in mind when sending code-fragments: they need to be able to trigger the bug without any of your other code. And please don't send me hundreds of lines of your code, as I can't debug it for you. Just concentrate on the line(s), that trigger the bug successfully.
               
               3. Send these notes either as:  
               Issue at the GitHub-Repository of the Ultraschall-API(preferred): [https://github.com/Ultraschall/Ultraschall-Api-for-Reaper.git](https://github.com/Ultraschall/Ultraschall-Api-for-Reaper.git)  
               eMail: lspmp3@yahoo.de(for framework-related stuff only!!)  
               Sendegate: [sendegate.de](http://www.sendegate.de) into the Ultraschall-section.  

            Bugreports that contain only a "it doesn't work" and "I expected it to work" will be ignored gracefully ;)

            If you have feature-requests, we have open ears. Keep in mind, not everything you find a good idea actually is one. So we may or may not take on your idea, change and rework it into a way, that benefits all, not just your particular use-case. When in doubt, just try it!
            Keep also in mind: there are limitations. Some cool features we all would love to have, simply aren't implementable. Que sera, sera...

            For your comments just send a mail at: lspmp3@yahoo.de(for framework-related stuff only!!) or go to sendegate.de into the Ultraschall-section.

            PS: If you know how to implement impossible things or do things better than the current implementation, you are welcome to donate your improved codes. :)
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Introduction
        </chapter_context>
        <previous_chapter>Introduction_003_How_to_Use_Beta_Functions_And_Hotfixes</previous_chapter>
        <next_chapter>Introduction_005_License</next_chapter>
        <tags>documentation, introduction, beta, hotfixes</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Introduction_005_License</slug>
        <title>Introduction: License</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
                         
             Copyright (c) 2014-2018 Ultraschall (http://ultraschall.fm)
             
             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated documentation files (the "Software"), to deal
             in the Software without restriction, including without limitation the rights
             to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             copies of the Software, and to permit persons to whom the Software is
             furnished to do so, subject to the following conditions:
             
             The above copyright notice and this permission notice shall be included in
             all copies or substantial portions of the Software.
             
             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
             
            

            Reaper and the Reaper-Logo are trademarks of Cockos inc and can be found at [reaper.fm](http://www.reaper.fm)

            The SWS-logo has been taken from the SWS-extension-project, which can be found at [sws-extension.org](http://www.sws-extension.org)
            
            Ultraschall-API written by Meo Mespotine[mespotine.de](http://www.mespotine.de) with contributions from [Udo Sauer](https://twitter.com/fernsehmuell) and [Ralf Stockmann](https://twitter.com/rstockm)
            If you want to donate to our project, head over to [ultraschall.fm/danke](http://www.ultraschall.fm/danke).
            
            Kudos to lokasenna, who suggested some cool things, that made some functions much faster and sparkled new ones. Cheers!
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Introduction
        </chapter_context>
        <previous_chapter>Introduction_004_Bugreporting_FeatureRequests</previous_chapter>
        <next_chapter>Datatypes_001_Introduction</next_chapter>
        <tags>documentation, introduction, license</tags>
    </US_DocBloc>

        <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Datatypes_001_Introduction</slug>
        <title>Datatypes: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Parameters and returnvalues are usually of specific types. Let's look at the following function:
            
            
                        integer number_of_items, array MediaItemArray, array MediaItemStateChunkArray = ultraschall.GetMediaItemsAtPosition(number position, string trackstring)
            
            
            The returnvalues number\_of\_items is of type integer, MediaItemArray is of type array/type, MediaItemStateChunkArray if of type array.
            The parameters position is of type number, trackstring is of type string.
            These parameters/returnvalues only accept/return data of these given types.

            The Ultraschall-API uses a lot of the standard-datatypes provided by Lua and Reaper/SWS, which are:
            
            * Lua            
                 * boolean - either true or false
                 * integer - an integer number
                 * number - a number, usually float but also accepts integers
                 * string - a string of characters
                 * table/array - a Lua-array
                 * function - a function as an object
                 * nil - the value "nothing"
               
            - Reaper
                 - ReaProject - a project/projecttab as an object
                 - MediaTrack - a track as an object; has all attributes of a track, as solo/mute-state, name, MediaItems lying in this track, etc
                 - MediaTrackStateChunk - a string containing an RPP-XML-description of all states/attributes of a MediaTrack
                 - MediaItem - an item as an object; has all attributes of an item, as length, position, volume, etc
                 - MediaItem_Take - a specific take of an item as an object; one item can have multiple takes
                 - MediaItemStateChunk - a string containing an RPP-XML-description of all states/attributes of a MediaItem
                 - TrackEnvelope - an envelope-lane as an object
                 - EnvelopeStateChunk - a string containing an RPP-XML-description of all states/attributes of a TrackEnvelope
                 - PCM_source - audio/video/image as an object; connects MediaItems to the actual media-file
                    
            If a datatype has "optional" before it, this parameter/returnvalue is optional. That means, such parameters don't need to be given, such return-values can be nil.
             
            In addition to the already used datatypes, the Ultraschall-API introduces some more datatypes, like:
            
               - [trackstrings](#Datatypes_002_trackstring) - some functions accept multiple tracks. Trackstrings are a string with all tracknumbers, separated by commas.
               - [MediaItemArray](#Datatypes_003_MediaItemArray) - some functions accept multiple mediaitems. MediaItemArrays are tables containing MediaItem-objects. The index of the table is integers.
               - [MediaItemStateChunkArray](#Datatypes_004_MediaItemStateChunkArray) - some functions accept multiple mediaitem-statechunks. MediaItemStateChunkArrays are tables containing MediaItemStateChunks. The index of the table is integers.
               - [EnvelopePointObject](#Datatypes_005_EnvelopePointObject) - it's a table containing all attributes of an envelope-point, 
                  like: parent TrackEnvelope-object, envelope-idx, time, value, shape, tension, selected, dBValue converted from value
               - [EnvelopePointArray](#Datatypes_006_EnvelopePointArray) - it's a table with multiple EnvelopePointObjects in it, indexed by an integer
               - [ColorTable][#Datatypes_007_ColorTable) - it's a table that holds multiple color-values; for i.e. gradients
                    
            These Ultraschall-API-specific datatypes are described in more detail in the following chapters.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Datatypes
        </chapter_context>
        <previous_chapter>Introduction_005_License</previous_chapter>
        <next_chapter>Datatypes_002_trackstring</next_chapter>
        <tags>documentation, datatypes, datatype, introduction</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Datatypes_002_trackstring</slug>
        <title>Datatypes: Trackstrings</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Many functions allow you to process through multiple tracks. As good as this is, this provided some difficulty in telling a function, to which track it shall be applied to.  
            Hence the datatype: trackstring
            
            A trackstring is just a simple string with all tracknumbers that you want a certain function to be applied to.  
            Examplecode:  
                
                        trackstring = "1,2,5,7,9"
                
            
            These tracknumbers must be separated from each other using a comma. Whitespaces are not allowed.  
            
            With trackstrings, passing the wanted tracks to a function is really easy.  
            
            - You can create trackstrings using:  
                    [CreateTrackString](usdocml://CreateTrackString), [CreateTrackString_AllTracks](usdocml://CreateTrackString_AllTracks), [CreateTrackString_ArmedTracks](usdocml://CreateTrackString_ArmedTracks), [CreateTrackString_UnarmedTracks](usdocml://CreateTrackString_UnarmedTracks), [CreateTrackString_SelectedTracks](usdocml://CreateTrackString_SelectedTracks).  
            - You can manipulate trackstrings using:  
                    [InverseTrackstring](usdocml://InverseTrackstring), [OnlyTracksInBothTrackstrings](usdocml://OnlyTracksInBothTrackstrings), [OnlyTracksInOneTrackstring](usdocml://OnlyTracksInOneTrackstring), [RemoveDuplicateTracksInTrackstring](usdocml://RemoveDuplicateTracksInTrackstring), [OnlyMediaItemsOfTracksInTrackstring](usdocml://OnlyMediaItemsOfTracksInTrackstring), [OnlyMediaItemsOfTracksInTrackstring_StateChunk](usdocml://OnlyMediaItemsOfTracksInTrackstring_StateChunk)
            - You can check for valid trackstrings using:  
                    [IsValidTrackString](usdocml://IsValidTrackString)
            - Some of the functions who make use of trackstrings are: 
                    [GetAllMediaItemsBetween](usdocml://GetAllMediaItemsBetween), [GetAllMediaItemsInTimeSelection](usdocml://GetAllMediaItemsInTimeSelection), [DeleteMediaItems_Position](usdocml://DeleteMediaItems_Position), [IsItemInTrack3](usdocml://IsItemInTrack3), and more

        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Datatypes
        </chapter_context>
        <previous_chapter>Datatypes_001_Introduction</previous_chapter>
        <next_chapter>Datatypes_003_MediaItemArray</next_chapter>
        <tags>documentation, datatypes, datatype, trackstring, trackstrings</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Datatypes_003_MediaItemArray</slug>
        <title>Datatypes: MediaItemArray</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Many functions allow you to process through multiple mediaitems. To be able to pass multiple mediaitems at once to a function, I added the datatype MediaItemArray.
            
            A MediaItemArray is an array with many MediaItems, indexed by an integer.  
            Examplecode:  
            
                        -- get the MediaItems
                        MediaItem1=reaper.GetMediaItem(0,0)
                        MediaItem2=reaper.GetMediaItem(0,1)
                        MediaItem3=reaper.GetMediaItem(0,2)
                        MediaItem4=reaper.GetMediaItem(0,3)
                        
                        -- create and fill the MediaItemArray
                        MediaItemArray={}
                        MediaItemArray[1]=MediaItem1
                        MediaItemArray[2]=MediaItem2
                        MediaItemArray[3]=MediaItem3
                        MediaItemArray[4]=MediaItem4
            
            MediaItemArrays will be read, until an index of the MediaItemArray is nil. In the above example, MediaItemArray[5] would be nil and therefore seen as the end of the array, even if there's a MediaItemArray[6]!
            
            With MediaItemArray, passing the wanted MediaItems to a function is really easy.
            
            - You can create MediaItemArrays using:  
                    [GetAllMediaItems](usdocml://GetAllMediaItems), [GetAllMediaItemsBetween](usdocml://GetAllMediaItemsBetween), [GetAllMediaItemsFromTrack](usdocml://GetAllMediaItemsFromTrack), [GetMediaItemsAtPosition](usdocml://GetMediaItemsAtPosition), [GetAllMediaItemsInTimeSelection](usdocml://GetAllMediaItemsInTimeSelection), etc
            - You can manipulate MediaItemArrays using:  
                    [ApplyActionToMediaItemArray](usdocml://ApplyActionToMediaItemArray), [ApplyFunctionToMediaItemArray](usdocml://ApplyFunctionToMediaItemArray), [InsertMediaItemArray](usdocml://InsertMediaItemArray), [ChangeDeltaLengthOfMediaItems_FromArray](usdocml://ChangeDeltaLengthOfMediaItems_FromArray), [ChangeDeltaOffsetOfMediaItems_FromArray](usdocml://ChangeDeltaOffsetOfMediaItems_FromArray), etc
            - You can check for valid MediaItemArrays using:  
                    [IsValidMediaItemArray](usdocml://IsValidMediaItemArray)
            - Some of the functions who make use of MediaItemArray are:  
                    [DeleteMediaItemsFromArray](usdocml://DeleteMediaItemsFromArray), [DeselectMediaItems_MediaItemArray](usdocml://DeselectMediaItems_MediaItemArray), [GetAllLockedItemsFromMediaItemArray](usdocml://GetAllLockedItemsFromMediaItemArray), [InsertMediaItemArray](usdocml://InsertMediaItemArray), and more
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Datatypes
        </chapter_context>
        <previous_chapter>Datatypes_002_trackstring</previous_chapter>
        <next_chapter>Datatypes_004_MediaItemStateChunkArray</next_chapter>
        <tags>documentation, datatypes, datatype, mediaitemarray</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Datatypes_004_MediaItemStateChunkArray</slug>
        <title>Datatypes: MediaItemStateChunkArray</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Many functions allow you to process through multiple mediaitem-statechunks. To be able to pass multiple mediaitem-statechunks at once to a function, I added the datatype MediaItemStateChunkArray.  
            
            A MediaItemStateChunkArray is an array with many MediaItemStateChunks, indexed by an integer.  
            Examplecode:  

                        -- get the MediaItems
                        MediaItem1=reaper.GetMediaItem(0,0)
                        MediaItem2=reaper.GetMediaItem(0,1)
                        MediaItem3=reaper.GetMediaItem(0,2)
                        MediaItem4=reaper.GetMediaItem(0,3)
                        
                        -- get the MediaItemStateChunks
                        StateChunk1=reaper.GetItemStateChunk(MediaItem1, "", false)
                        StateChunk2=reaper.GetItemStateChunk(MediaItem2, "", false)
                        StateChunk3=reaper.GetItemStateChunk(MediaItem3, "", false)
                        StateChunk4=reaper.GetItemStateChunk(MediaItem4, "", false)
                        
                        -- create and fill the MediaItemStateChunkArray
                        MediaItemStateChunkArray={}
                        MediaItemStateChunkArray[1]=StateChunk1
                        MediaItemStateChunkArray[2]=StateChunk2
                        MediaItemStateChunkArray[3]=StateChunk3
                        MediaItemStateChunkArray[4]=StateChunk4

            
            MediaItemStateChunkArrays will be read, until an index of the MediaItemStateChunkArray is nil. In the above example, MediaItemStateChunkArray[5] would be nil and therefore seen as the end of the array, even if there's a MediaItemStateChunkArray[6]!  
            
            With MediaItemStateChunkArrays, passing the wanted MediaItemStateChunks to a function is really easy.  
            
            - You can create MediaItemStateChunkArrays using:  
                    [GetAllMediaItems](usdocml://GetAllMediaItems), [GetAllMediaItemsBetween](usdocml://GetAllMediaItemsBetween), [GetAllMediaItemsFromTrack](usdocml://GetAllMediaItemsFromTrack), [GetMediaItemsAtPosition](usdocml://GetMediaItemsAtPosition), [GetAllMediaItemsInTimeSelection](usdocml://GetAllMediaItemsInTimeSelection), etc
            - You can manipulate MediaItemStateChunkArrays using:  
                    [AddLockStateTo_MediaItemStateChunkArray](usdocml://AddLockStateTo_MediaItemStateChunkArray), [ApplyStateChunkToItems](usdocml://ApplyStateChunkToItems), [OnlyMediaItemsOfTracksInTrackstring_StateChunk](usdocml://OnlyMediaItemsOfTracksInTrackstring_StateChunk), etc
            - You can check for valid MediaItemStateChunkArrays using:  
                    [IsValidMediaItemStateChunkArray](usdocml://IsValidMediaItemStateChunkArray)
            - Some of the functions who make use of MediaItemStateChunkArrays are:  
                    [GetMediaItemStateChunkArrayLength](usdocml://GetMediaItemStateChunkArrayLength), [InsertMediaItemStateChunkArray](usdocml://InsertMediaItemStateChunkArray), [RippleInsert_MediaItemStateChunks](usdocml://RippleInsert_MediaItemStateChunks), [GetAllMediaItemsFromTrackStateChunk](usdocml://GetAllMediaItemsFromTrackStateChunk) and more
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Datatypes
        </chapter_context>
        <previous_chapter>Datatypes_003_MediaItemArray</previous_chapter>
        <next_chapter>Datatypes_005_EnvelopePointObject</next_chapter>
        <tags>documentation, datatypes, datatype, mediaitemstatechunkarray</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Datatypes_005_EnvelopePointObject</slug>
        <title>Datatypes: EnvelopePointObject</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When working with envelope-points, handling all the attributes such an envelope-point is quite unhandy. So I introduced the datatype EnvelopePointObject, containing all it's attributes.  
            
            An EnvelopePointObject is an array with all attributes an envelope-point has.  
            Examplecode: 

                        MediaTrack=reaper.GetTrack(0,0) -- get MediaTrack
                        TrackEnvelope=reaper.GetTrackEnvelope(MediaTrack, 0) -- get TrackEnvelope
                        retval, EnvelopePointObject = ultraschall.CreateEnvelopePointObject(TrackEnvelope, 1, 20, 10, 0, 0, false) -- create EnvelopePointObject

            
            An EnvelopePointObject is an array with all the attributes of an envelope-point, containing the following values:
            
                        EnvelopePointObject[1] - Trackenvelope; The TrackEnvelope-object, in which the point lies
                        EnvelopePointObject[2] - integer; Envelope-idx
                        EnvelopePointObject[3] - number; the time in seconds
                        EnvelopePointObject[4] - number; the raw value of the envelope-point
                        EnvelopePointObject[5] - integer; the shape of the envelope-point, with 
                                                               0 - Linear
                                                               1 - Square
                                                               2 - Slow start/end
                                                               3 - Fast start
                                                               4 - Fast end
                                                               5 - Bezier
                        EnvelopePointObject[6] - number; tension of the envelope-point; -1 to 1; 0 for no tension
                        EnvelopePointObject[7] - boolean; if the envelope-point is selected(true) or not(false)
                        EnvelopePointObject[8] - number; dBValue converted from value
            
            EnvelopePointObjects make handling of envelope-points and it's attributes much easier.
            
            - You can create EnvelopePointObjects, using: 
                    [CreateEnvelopePointObject](usdocml://CreateEnvelopePointObject), [GetEnvelopePoint](usdocml://GetEnvelopePoint), etc
            - You can check for valid EnvelopePointObjects using: 
                    [IsValidEnvelopePointObject](usdocml://IsValidEnvelopePointObject)
            - Some of the functions who make use of EnvelopePointObjects are: 
                    [AddEnvelopePoints_EnvelopePointObject](usdocml://AddEnvelopePoints_EnvelopePointObject), [SetEnvelopePoints_EnvelopePointObject](usdocml://SetEnvelopePoints_EnvelopePointObject), [DeleteEnvelopePoints_EnvelopePointObject](usdocml://DeleteEnvelopePoints_EnvelopePointObject) and more
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Datatypes
        </chapter_context>
        <previous_chapter>Datatypes_004_MediaItemArray</previous_chapter>
        <next_chapter>Datatypes_006_EnvelopePointArray</next_chapter>
        <tags>documentation, datatypes, datatype, envelopepointobject</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Datatypes_006_EnvelopePointArray</slug>
        <title>Datatypes: EnvelopePointArray</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When working with multiple EnvelopePointObjects, I introduced the datatype EnvelopePointArray, containing multiple EnvelopePointObjects.
            
            An EnvelopePointArray is an array with multiple EnvelopePointObjects, indexed by an integer.  
            Examplecode:  

                        -- create EnvelopePointObjects
                        MediaTrack=reaper.GetTrack(0,0) -- get MediaTrack
                        TrackEnvelope=reaper.GetTrackEnvelope(MediaTrack, 0) -- get TrackEnvelope
                        retval, EnvelopePointObject1 = ultraschall.CreateEnvelopePointObject(TrackEnvelope, 1, 20, 10, 0, 0, false) -- create EnvelopePointObject1
                        retval, EnvelopePointObject2 = ultraschall.CreateEnvelopePointObject(TrackEnvelope, 1, 20, 10, 0, 0, false) -- create EnvelopePointObject2
                        retval, EnvelopePointObject3 = ultraschall.CreateEnvelopePointObject(TrackEnvelope, 1, 20, 10, 0, 0, false) -- create EnvelopePointObject3
                        
                        -- creating EnvelopePointArray
                        EnvelopePointArray={}
                        EnvelopePointArray[1]=EnvelopePointObject1
                        EnvelopePointArray[2]=EnvelopePointObject2
                        EnvelopePointArray[3]=EnvelopePointObject3
            
            EnvelopePointArray makes passing multiple EnvelopePointObjects to functions much easier.
            
            - You can create EnvelopePointArrays using: 
                    [GetEnvelopePointIDX_Between](usdocml://GetEnvelopePointIDX_Between)
            - You can check for valid EnvelopePointArrays using: 
                    [IsValidEnvelopePointArray](usdocml://IsValidEnvelopePointArray)
            - Some of the functions who make use of EnvelopePointArrays are: 
                    [AddEnvelopePoints_EnvelopePointArray](usdocml://AddEnvelopePoints_EnvelopePointArray), [SetEnvelopePoints_EnvelopePointArray](usdocml://SetEnvelopePoints_EnvelopePointArray), [DeleteEnvelopePoints_EnvelopePointArray](usdocml://DeleteEnvelopePoints_EnvelopePointArray) and more
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Datatypes
        </chapter_context>
        <previous_chapter>Datatypes_005_EnvelopePointObject</previous_chapter>
        <next_chapter>Datatypes_007_ColorTable</next_chapter>
        <tags>documentation, datatypes, datatype, envelopepointarray</tags>
    </US_DocBloc>


    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Datatypes_007_ColorTable</slug>
        <title>Datatypes: ColorTable</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When having to work with many colors, like MediaTrack-colors or the colors set to individual MediaItems, one may wish to have a proper datastructure to store these colorvalues.
            For that, I introduce the ColorTable.
            
            A ColorTable is an array containing the multiple colors, indexed by an integer.  
            Structure:  

                        ColorTable[index]["r"]=red color-value(0-255)
                        ColorTable[index]["g"]=green color-value(0-255)
                        ColorTable[index]["b"]=blue color-value(0-255)
                        ColorTable[index]["gfxr"]=red color-value, useable by gfx-related-functions(0-1)
                        ColorTable[index]["gfxg"]=green color-value, useable by gfx-related-functions(0-1)
                        ColorTable[index]["gfxb"]=blue color-value, useable by gfx-related-functions(0-1)
                        ColorTable[index]["nativecolor"]=the r-g-b-color-value converted to the native-color, used in your system
                    
            
            ColorTables can be used to store gradients, or temporary track-colors, or anything related to multiple colors.
            
            - You can create ColorTables using: 
                    [CreateColorTable](usdocml://CreateColorTable), [CreateSonicRainboomColorTable](usdocml://CreateSonicRainboomColorTable)
            - You can check for valid ColorTables using: 
                    [IsValidColorTable](usdocml://IsValidColorTable)
            - Some of the functions who make use of ColorTables are: 
                    [ApplyColorTableToTrackColors](usdocml://ApplyColorTableToTrackColors)            
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Datatypes
        </chapter_context>
        <previous_chapter>Datatypes_006_EnvelopePointObject</previous_chapter>
        <next_chapter>Datatypes_050_CheckingDatatypes</next_chapter>
        <tags>documentation, datatypes, datatype, envelopepointarray</tags>
    </US_DocBloc>    
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Datatypes_050_CheckingDatatypes</slug>
        <title>Datatypes: Checking Datatypes</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When you work with data of different sources but need to work with data of a specific type, it would be handy to have ways of checking, whether a certain variable has data of a specific type.  
            Lua provides ways of checking for valid datatypes(type() and math.type()) as well as Reaper(ValidatePtr() and ValidatePtr2()).  
            
            However, sometimes you want to have one function to check them all, and all these functions do not include Ultraschall-API-specific datatypes, so I added some stuff for that.  
            
            1. [type](usdocml://type)  
                   works like Lua's own type-function, but checks for Reaper's own datatypes as well, like:  
                   
                           Lua: nil, number: integer, number: float, boolean, string, function, table, thread, userdata,  
                           Reaper: ReaProject, MediaItem, MediaItem_Take, MediaTrack, TrackEnvelope, AudioAccessor, joystick_device, PCM_source  
                           userdata: will be shown, if object isn't of any known type  
                        
                   to get of which type a variable is, just use  
     
                            datatype_of_variable = ultraschall.type(variable)
               
                   where the return-value datatype\_of\_variable will hold a string describing the type of the variable.  
                   
                   Due some API-restrictions, SWS-specific datatypes are not (yet) supported.  
               
            2. Ultraschall-API specific or other Reaper-datatypes  
                To check for Ultraschall-API specific or other Reaper-datatypes, you can use the following functions:  

                Ultraschall-API-specific:
                
                   - [IsValidTrackString](usdocml://IsValidTrackString) - checks, if a string is a valid [trackstring](#Datatypes_002_trackstring)  
                   - [IsValidMediaItemArray](usdocml://IsValidMediaItemArray) - checks, if a table is a valid [MediaItemArray](#Datatypes_003_MediaItemArray)  
                   - [IsValidMediaItemStateChunkArray](usdocml://IsValidMediaItemStateChunkArray) - checks, if a table is a valid [MediaItemStateChunkArray](#Datatypes_004_MediaItemStateChunkArray)  
                   - [IsValidEnvelopePointObject](usdocml://IsValidEnvelopePointObject) - checks, if a table is a valid [EnvelopePointObject](#Datatypes_005_EnvelopePointObject)  
                   - [IsValidEnvelopePointArray](usdocml://IsValidEnvelopePointArray) - checks, if a table is a valid [EnvelopePointArray](#Datatypes_006_EnvelopePointArray)
                   - [IsValidArrangeviewSnapshot](usdocml://IsValidArrangeviewSnapshot) - checks, if an extstate is a valid ArrangeviewSnapshot
                    
                Other Reaper-datatypes:
                
                   - [IsValidReaProject](usdocml://IsValidReaProject) - checks, if an object is a valid ReaProject
                   - [IsValidProjectStateChunk](usdocml://IsValidProjectStateChunk) - checks, if a string is a valid ProjectStateChunk
                   - [IsValidTrackStateChunk](usdocml://IsValidTrackStateChunk) - checks, if a string is a valid TrackStateChunk
                   - [IsValidMediaItemStateChunk](usdocml://IsValidMediaItemStateChunk) - checks, if a string is a valid MediaItemStateChunk
                   - [IsValidEnvStateChunk](usdocml://IsValidEnvStateChunk) - checks, if a string is a valid EnvelopeStateChunk
                    
                They will be part of ultraschall.type() someday.
                
            3. other types of data  
                These aren't datatypes, but you may want to check them for validity as well  
                
                   - [IsValidGuid](usdocml://IsValidGuid) - checks, whether a string is a valid GUID  
                   - [IsValidMatchingPattern](usdocml://IsValidMatchingPattern) - checks, whether a string is a valid matching pattern for Lua's pattern-matching  
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Datatypes
        </chapter_context>
        <previous_chapter>Datatypes_70_ColorTable</previous_chapter>
        <next_chapter>API_Variables_001_Introduction</next_chapter>
        <tags>documentation, datatypes, datatype, checking</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>API_Variables_001_Introduction</slug>
        <title>API-Variables</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When working with the Ultraschall-API or general programming in Reaper, some additional things may or may not be helpful to know.  
            So I added some API-variables, like:
            
               1. [Script_Path](usdocml://Script_Path) - which contains the current path to Reaper's-scripts-folder
               2. [Separator](usdocml://Separator) - which contains the correct separator for paths; on Windows it is \ on Mac and Linux it is /
               3. [StartTime](usdocml://StartTime) - contains the starting time of the Ultraschall-API as used in the current script. That means, the starting time of the now running script.
               4. [Api_Path](usdocml://Api_Path) - the current path to the Ultraschall-API folder.
               5. [Api_InstallPath](usdocml://Api_InstallPath) - an API-variable that contains the path to the install-folder of the Ultraschall-API
               
            These can be accessed using:
            
                            scriptpath = ultraschall.Script_Path
                    
            which would put the current-scriptpath to the variable scriptpath. 
            
            You could change them as well, but that would be pointless.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            API-Variables
        </chapter_context>
        <previous_chapter>Datatypes_050_CheckingDatatypes</previous_chapter>
        <next_chapter>Rendering_001_Introduction</next_chapter>
        <tags>documentation, api-variables</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Rendering_001_Introduction</slug>
        <title>Rendering: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            The Ultraschall-API provides functions for rendering your projects, without having to use the Rendering-dialog of Reaper. 
            This gives you a wide range of possibilities to customize your rendering-needs. 
            
            Basically the process is based on:  
                
               1. creating a renderstring with all format-specific-settings, using the accompanying functions:  
                   [CreateRenderCFG_AIFF](usdocml://CreateRenderCFG_AIFF), [CreateRenderCFG_DDP](usdocml://CreateRenderCFG_DDP), [CreateRenderCFG_FLAC](usdocml://CreateRenderCFG_FLAC), [CreateRenderCFG_MP3ABR](usdocml://CreateRenderCFG_MP3ABR), [CreateRenderCFG_MP3CBR](usdocml://CreateRenderCFG_MP3CBR), 
                   [CreateRenderCFG_MP3MaxQuality](usdocml://CreateRenderCFG_MP3MaxQuality), [CreateRenderCFG_MP3VBR](usdocml://CreateRenderCFG_MP3VBR), [CreateRenderCFG_OGG](usdocml://CreateRenderCFG_OGG), [CreateRenderCFG_Opus](usdocml://CreateRenderCFG_Opus),  
                   [CreateRenderCFG_Opus2](usdocml://CreateRenderCFG_Opus2), [CreateRenderCFG_WAV](usdocml://CreateRenderCFG_WAV), [CreateRenderCFG_WAVPACK](usdocml://CreateRenderCFG_WAVPACK), [CreateRenderCFG_WebMVideo](usdocml://CreateRenderCFG_WebMVideo)  
                    
               2. passing the render-string to one of the Render-functions  
                   [RenderProject_RenderCFG](usdocml://RenderProject_RenderCFG), [RenderProjectRegions_RenderCFG](usdocml://RenderProjectRegions_RenderCFG)
                    
               So the following code should render the current project into an MP3 with a Constant Bitrate of 128kbps.
               Note: to render the currently opened project, it must be saved first!
               
                       -- create Render-string
                       render_cfg_string = ultraschall.CreateRenderCFG_MP3CBR(11, 2)
                       
                       -- Pass this Render-string to the rendering-function
                       retval = ultraschall.RenderProject_RenderCFG(nil, "c:\\exportfile.mp3", 0, -1, false, false, false, render_cfg_string)
               
               One downside, though: when you want to render the currently opened project, it will be opened a second time for the rendering.  
               So if the current project has many effect-plugins and/or uses much memory, this means, the rendering of the current project using the UltraschallAPI-functions needs twice the ressources of your project!
               This is due Reaper-limitations, unfortunately.
               
               Read the accompanying documentation-entries for [CreateRenderCFG_MP3CBR](usdocml://CreateRenderCFG_MP3CBR) and [RenderProject_RenderCFG](usdocml://RenderProject_RenderCFG) for more details and/or the following chapters.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Rendering
        </chapter_context>
        <previous_chapter>API_Variables_001_Introduction</previous_chapter>
        <next_chapter>Rendering_002_About_Renderstrings</next_chapter>
        <tags>documentation, introduction, rendering, projects, functions, render</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Rendering_002_About_Renderstrings</slug>
        <title>Rendering: About Renderstrings</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Render-strings(or render_cfg, as they are named in Reaper) are strings, that contain all settings for a specific Render-Output-format, as MP3, WAV, AIF, FLAC, etc.  
            They are usually stored into RPP-projectfiles and are quite cryptic(for those of you, who know what that means: BASE64-encoded).  
            These are essential for rendering a project using the provided rendering-functions, so the Ultraschall-API provides functions who create these render-strings.  
            
            All these functions start with CreateRenderCFG_ in their name, so if you are looking for a specific format, use CreateRenderCFG\_audioformat (like CreateRenderCFG\_FLAC, etc).   
            The parameters of these functions represent all format-options as you are used from the Render-dialog. They should be fairly complete, though some formats (Video, OGG) are limited with some of their options(fps, width, height, kbps, etc).  
            This is due my approach decoding them, though I tried to provide all settings that are useful in your everyday use(documented in the accompanying parameter-descriptions in the functions-reference).  
            
            Example for FLAC:
            

                        render_string = ultraschall.CreateRenderCFG_FLAC(integer BitDepth, integer EncSpeed)

            
            creates the render-string for the FLAC-fileformat. Just provide the BitDepth(e.g 0 for 24 Bit) and the encoding-speed(EncSpeed) (e.g 5 for the default encoding speed).   
            Have a look into the functions-reference to get the possible values for these parameters.
            

                        render_string = ultraschall.CreateRenderCFG_FLAC(0, 5)

            
            This will create a render-string for FLAC with 24bit-depth and the encoding-speed of 5(which is the default-setting in the render-dialog).
            
            This renderstring can then be passed over to [SetProject_RenderCFG](usdocml://SetProject_RenderCFG) to set it into a project-file, or to [RenderProject_RenderCFG](usdocml://RenderProject_RenderCFG) to render a projectfile using the format-settings in the Render-string.
            
            The following render-string-functions are available in Ultraschall-API:  
                     [CreateRenderCFG_AIFF](usdocml://CreateRenderCFG_AIFF), [CreateRenderCFG_DDP](usdocml://CreateRenderCFG_DDP), [CreateRenderCFG_FLAC](usdocml://CreateRenderCFG_FLAC), [CreateRenderCFG_MP3ABR](usdocml://CreateRenderCFG_MP3ABR), [CreateRenderCFG_MP3CBR](usdocml://CreateRenderCFG_MP3CBR), [CreateRenderCFG_MP3MaxQuality](usdocml://CreateRenderCFG_MP3MaxQuality), 
                     [CreateRenderCFG_MP3VBR](usdocml://CreateRenderCFG_MP3VBR), [CreateRenderCFG_OGG](usdocml://CreateRenderCFG_OGG), [CreateRenderCFG_Opus](usdocml://CreateRenderCFG_Opus), [CreateRenderCFG_Opus2](usdocml://CreateRenderCFG_Opus2), [CreateRenderCFG_WAV](usdocml://CreateRenderCFG_WAV), [CreateRenderCFG_WAVPACK](usdocml://CreateRenderCFG_WAVPACK),  
                     [CreateRenderCFG_WebMVideo](usdocml://CreateRenderCFG_WebMVideo)            
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Rendering
        </chapter_context>
        <previous_chapter>Rendering_001_Introduction</previous_chapter>
        <next_chapter>Rendering_003_About_Renderingfunctions</next_chapter>
        <tags>documentation, rendering, projects, functions, render, renderstring, rendercfg, render_cfg</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Rendering_003_About_Renderingfunctions</slug>
        <title>Rendering: About Rendering-functions</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            The rendering-functions let you render a project, either a stored rpp-project-file or the currently opened one(only when it has been saved!).  
            They provide you with a wide range of functionality, so the rendering process should be quite close to Reaper's "official"-own-process using the render-dialog.  
            
            There are currently two different render-functions available:  
            
            1. [RenderProject_RenderCFG](usdocml://RenderProject_RenderCFG) - with this one, you can render a whole project or just from startposition to endposition in seconds
            2. [RenderProjectRegions_RenderCFG](usdocml://RenderProjectRegions_RenderCFG) with this one, you can render specific regions of a project
            
            Basically they are the same, with the only difference, that with the first one you can set a specific startposition and endposition, while the second one, you set it to a region-number.  
            That said, a lot of the parameters are the same.
            
                         projectfilename_with_path - the projectfile with path, that you want to render. Set it to nil, if you want to render the 
                                                     currently opened project(which must be saved before rendering!)
                         renderfilename_with_path  - the filename with path of the output-file
                         overwrite_without_asking  - if you want to overwrite already existing outputfiles, set this to true; else, set it to false
                
            The following two are directly connected to some of Reaper's dialogs:
            
                         renderclosewhendone - the render-progress-window, that is shown during the actual rendering can be closed automatically after  
                                               rendering is finished(there's a checkbox in that window to set this). Set this to true to automatically 
                                               close it; set it to false to keep it shown; set it to nil and it will use the setting the user set with 
                                               the checkbox
                         filenameincrease    - another of Reaper's dialogs, that will pop up, when an output-file already exists and overwrite_without_asking 
                                               is set to false. It will ask you to automatically increase the filename with a number to prevent accidental 
                                               overwriting. Set this to true to automatically increase filename; 
                                               set it to false to show the dialog; set it to nil to use the settings the user chose
                
            The last parameter is the place for your render-string:
            
                         rendercfg           - the renderstring, as created using a CreateRenderCFG_XXX-function, as described in 
                                               the chapter "Rendering: About Renderstrings"
                                               if you omit it or set it to nil, it will use the format-settings already set in the projectfile
            
            With that, you should be able to successfully render your project.
            
            For more enhanced customization of Rendering, see [Rendering: Change more render-settings](#Rendering_004_Change_more_render_settings) for more details.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Rendering
        </chapter_context>
        <previous_chapter>Rendering_002_About_Renderstrings</previous_chapter>
        <next_chapter>Rendering_004_Change_more_render_settings</next_chapter>
        <tags>documentation, rendering, projects, functions, render, renderstring, rendercfg, render_cfg</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Rendering_004_Change_more_render_settings</slug>
        <title>Rendering: Change more render-settings</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Reaper's own render-dialog provides you with much more possibilities, than the rendering-functions themselves provide you with.
            
            In the likely case, that you want to influence more things for rendering, like samplerate, stereo or mono, etc, you should do the following things:
            
            1. make a copy of the rpp-file that you want to render using [MakeCopyOfFile](usdocml://MakeCopyOfFile). The copy must have a different name and be in the same folder, as the original rpp-file!
            2. Now you can alter the copy of the projectfile using the following Ultraschall-Framework-functions, that represent certain elements from Reaper's Render-Dialog:
            
                - [SetProject_RenderFilename](usdocml://SetProject_RenderFilename) - to alter the output-filename
                - [SetProject_RenderPattern](usdocml://SetProject_RenderPattern) - to set the wildcards for the output-filename 
                - [SetProject_RenderDitherState](usdocml://SetProject_RenderDitherState) - to set the "Master mix: Dither/Noise shaping"-checkboxes
                - [SetProject_RenderFreqNChans](usdocml://SetProject_RenderFreqNChans) - to set the Sample rate in Hz and Channels
                - [SetProject_RenderRange](usdocml://SetProject_RenderRange) - to set Bounds-dropdownlist, Time bounds-entryboxes and Tail
                - [SetProject_RenderResample](usdocml://SetProject_RenderResample) - to set "Resample mode (if needed)" 
                - [SetProject_RenderSpeed](usdocml://SetProject_RenderSpeed) to set the render-speed, and
                - [SetProject_RenderStems](usdocml://SetProject_RenderStems) to set, whether to render stems, Master mix, region-render-matrix, etc (Source-dropdownlist)  
                
            3. after you've set the individual render-settings, you create a render-string, as described in [Rendering: About Renderstrings](#Rendering_002_About_Renderstrings).  
            
            4. render using the altered copy(!) of the projectfile(not the original projectfile!), as described in [Rendering: About Rendering-functions](#Rendering_003_About_Renderingfunctions).
            
            If you want to alter the currently opened project, you need to save it first. After that, use:
            
                        retval, projectfilename_with_path = reaper.EnumProjects(-1,"")
            
            to get the projectfilename\_with\_path of the current project as returnvalue. Use projectfilename\_with\_path and go through steps 1 through 4.
            
            The functions in step 2) are just a small selection of the functions to alter project-files, as provided by the Ultraschall-API. Browse through the functions in the "Project-Files"-section of the index of the Ultraschall-API-Functions-Reference for many more of them.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Rendering
        </chapter_context>
        <previous_chapter>Rendering_003_About_Renderingfunctions</previous_chapter>
        <next_chapter>Arrangeview_Snapshots_001_Introduction</next_chapter>
        <tags>documentation, rendering, projects, functions, render, renderstring, rendercfg, render_cfg, advanced</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Arrangeview_Snapshots_001_Introduction</slug>
        <title>Arrangeview Snapshots: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When working with big or complex projects: 
            
            Sometimes it's a good thing to have quick access to certain parts of the project, certain view-settings, zoom-factors. Arrangeview-snapshots are meant to help with that.
            
            Arrangeview-Snapshots are snapshots that store the current position of the arrangeview as well as it's zoom-factor. You can decide, whether to store only the zoom-factor or the position. You can also give a short description to a ArrangeView-Snapshot, so you can store, what to expect from a certain snapshot.  
            They can be retrieved and the arrange-view can be set to these settings. That way, quick navigation through often accessed parts of the project is fast and easy.
            
            Arrangeview-Snapshots are stored as ProjExtStates, which means, that the settings are stored in the project itself and can be retrieved the next time the project is loaded.
            
            Due limitations with Reaper's own API, storing the vertical-scroll-position of the arrangeview isn't possible yet. This will change as soon as the limitation is raised from Reaper's own API.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Arrangeview Snapshots
        </chapter_context>
        <previous_chapter>Rendering_004_Change_more_render_settings</previous_chapter>
        <next_chapter>Arrangeview_Snapshots_002_HowToStoreRetrieveDelete</next_chapter>
        <tags>documentation, arrangeview-snapshots, introduction</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Arrangeview_Snapshots_002_HowToStoreRetrieveDelete</slug>
        <title>Arrangeview Snapshots: How to store, retrieve, delete</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            If you want to store the current position and zoom-factor of the Arrangeview, you can use the function [StoreArrangeviewSnapshot](usdocml://StoreArrangeviewSnapshot).  
            
            It accepts the following parameters:
            
                        slot        - the slot for the snapshot, which must be an integer. The function will overwrite an already existing snapshot. To prevent that,
                                      use ultraschall.IsValidArrangeviewSnapshot() to check, if it's already existing.
                        description - a short description, what the snapshot contains so you know, what to expect from it
                        position    - set to true to store the startposition and endposition of the arrangeview. Otherwise(false), it will only store the current horizontal zoom-factor
                        vzoom       - set to true, if you want to store the vertical zoom-factor as well; set to false, if you don't want it to be stored.
                
            If you want to retrieve the settings of a certain Arrange-View-Snapshot, you can use [RetrieveArrangeviewSnapshot](usdocml://RetrieveArrangeviewSnapshot), which will
            return all settings from an Arrangeview-snapshot. The return-values of RetrieveArrangeviewSnapshot basically work the same as the parameters of StoreArrangeviewSnapshot.
            
            If you want to check, whether a slot is already used, you can use [IsValidArrangeviewSnapshot](usdocml://IsValidArrangeviewSnapshot), which will return true in that case and false, if the slot is unused.
            
            To delete a certain slot, just use [DeleteArrangeviewSnapshot](usdocml://DeleteArrangeviewSnapshot).
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Arrangeview Snapshots
        </chapter_context>
        <previous_chapter>Arrangeview_Snapshots_001_Introduction</previous_chapter>
        <next_chapter>Arrangeview_Snapshots_003_HowToRestore</next_chapter>
        <tags>documentation, arrangeview-snapshots, retrieve, store, delete</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Arrangeview_Snapshots_003_HowToRestore</slug>
        <title>Arrangeview Snapshots: How to restore</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When having stored an Arrangeview-Snapshot into a slot, you certainly want to restore it at one point. For that, use [RestoreArrangeviewSnapshot](usdocml://RestoreArrangeviewSnapshot).
            
            This function let's you restore an earlier arrange-view completely, but also allows you to individually set, what you want to restore, using the parameters:  
            
                        slot        - is the Arrangeview-Snapshot you want to restore
                
            the other parameters are optional, means, if you omit them or set them to nil, they will restore the setting from the snapshot or use a default setting
            
                        position    - true, restore the start and endposition of the arrange-view; false, just restore the horizontal-zoom-factor
                        vzoom       - set to true to restore the vertical zoom-factor or set to false to keep the current one
                        hcentermode - this decides, what shall be in the center of the arrangeview, when position is set to false, with several options possible:
                                       nil, keeps center of view in the center during zoom(default setting)
                                        -1, default selection, as set in the reaper-prefs, 
                                         0, edit-cursor or playcursor(if it's in the current zoomfactor of the view during playback/recording) in center,
                                         1, keeps edit-cursor in center of zoom
                                         2, keeps center of view in the center during zoom
                                         3, keeps in center of zoom, what is beneath the mousecursor
                         
            This should give you full control in what to restore from an Arrangeview-Snapshot and what to ignore.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Arrangeview Snapshots
        </chapter_context>
        <previous_chapter>Arrangeview_Snapshots_002_HowToStoreRetrieveDelete</previous_chapter>
        <next_chapter>Navigation_001_Introduction</next_chapter>
        <tags>documentation, arrangeview-snapshots, restore</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Navigation_001_Introduction</slug>
        <title>Navigation: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When editing and postproducing a project, navigating through it is essential. For that, I added some functions that are not part of Reaper's own API, to help navigation, with functions for:
            
               1. more control about moving the playcursor and the editcursor
               2. jumping to the next/previous closest marker/regionedge/itemedge
               3. centering the view to several possible center-positions selectable(mousecursor, editcursor, playcursor)
               4. Followmode, aka autoscrolling
            
            This should give you more control about programming faster and quicker navigation-capabilities.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Navigation
        </chapter_context>
        <previous_chapter>Arrangeview_Snapshots_003_HowToRestore</previous_chapter>
        <next_chapter>Navigation_002_MovePlay_and_Editcursor</next_chapter>
        <tags>documentation, arrangeview, navigation, introduction</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Navigation_002_MovePlay_and_Editcursor</slug>
        <title>Navigation: Move Play and Editcursor</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            The Ultraschall-API provides you with many functions regarding changing the position of the playcursor and the editcursor.  
            For that we have numerous functions:  
                
               - Editcursor only:
                  - [JumpForwardBy](usdocml://JumpForwardBy) - jumps forward editcursor by as many seconds you like; optionally you can move the playcursor as well to the new position.
                  - [JumpBackwardBy](usdocml://JumpBackwardBy) - jumps backward editcursor by as many seconds you like; optionally you can move the playcursor as well to the new position.
               
               - Playcursor only:
                  - [SetPlayCursor_WhenPlaying](usdocml://SetPlayCursor_WhenPlaying) - sets the playcursor to a new position, during playing
                  - [JumpForwardBy_Recording](usdocml://JumpForwardBy_Recording) - stops recording, jumps forward a given amount of seconds and resumes recording
                  - [JumpBackwardBy_Recording](usdocml://JumpBackwardBy_Recording) - stops recording, jumps backward a given amount of seconds and resumes recording
                   
               - Both:
                  - [SetPlayAndEditCursor_WhenPlaying](usdocml://SetPlayAndEditCursor_WhenPlaying) - sets play and editcursor to position during playback
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Navigation
        </chapter_context>
        <previous_chapter>Navigation_001_Introduction</previous_chapter>
        <next_chapter>Navigation_003_GotoMarkersRegionItemEdges</next_chapter>
        <tags>documentation, arrangeview, navigation, playcursor, editcursor</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Navigation_003_GotoMarkersRegionItemEdges</slug>
        <title>Navigation: Go to markers, regionedges and itemedges</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Markers and items provide you with much additional helpful information regarding the project. They also provide you with an additional information: useful positions to navigate through.  
            To make use of that, I added some functions for that:  
            
               1. [GetClosestPreviousMarker](usdocml://GetClosestPreviousMarker), [GetClosestNextMarker](usdocml://GetClosestNextMarker) - Get the previous/next closest marker at a given position
               2. [GetClosestPreviousRegionEdge](usdocml://GetClosestPreviousRegionEdge), [GetClosestNextRegionEdge](usdocml://GetClosestNextRegionEdge) - Get the previous/next closest regionedge at a given position
               3. [GetPreviousClosestItemEdge](usdocml://GetPreviousClosestItemEdge), [GetNextClosestItemEdge](usdocml://GetNextClosestItemEdge) - Get the previous/next closest itemedge at a given position
               4. [GetClosestGoToPoints](usdocml://GetClosestGoToPoints) - get previous/next markers/regionedges/itemedges/projectstart/projectend from position, for those who need the full marker/region/item-position-package
            
            Let's go into more detail, by examining [GetClosestPreviousRegionEdge](usdocml://GetClosestPreviousRegionEdge).
                
                
                        number markerindex, number position, string markername, string edge_type = 
                                                                    ultraschall.GetClosestPreviousRegionEdge(integer cursor_type, optional number time_position)
                
                
            This function allows you to get, which is the previous closest region-edge-position(either the start or the end of a region) as seen from a given position. 
            To set that position, you need to set the parameter cursor_type:  
            
                        0 - Edit Cursor,   
                        1 - Play Cursor,   
                        2 - Mouse Cursor, or  
                        3 - Timeposition  

            If you set it to 3, you can use the optional parameter time_position, with which you can set any position, at which you want to know the previous closest region-edge.
            
            If you run that function, it will return the markerindex, which is the index of all markers in your project, the position at which the regionedge is located, the markername and the type of the edge, which is either "beg" or "end".
            
            The Marker-functions (from 1) ) work the same, the Item-edge-functions (from 3) ) however have an additional parameter trackstring, with which you can set, from which tracks you want to get the next/previous closest item-edge-position.
            
            
            The function [GetClosestGoToPoints](usdocml://GetClosestGoToPoints) is the combination of all of these functions, which let's you decide fully, which edges/positions you want to check for.   
            It will also check, if the next/previous closest edge is the beginning or the end of the project.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Navigation
        </chapter_context>
        <previous_chapter>Navigation_002_MovePlay_and_Editcursor</previous_chapter>
        <next_chapter>Navigation_004_CenterView</next_chapter>
        <tags>documentation, arrangeview, navigation, playcursor, editcursor, marker, regions, region, edge, item, projectstart, projectend</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Navigation_004_CenterView</slug>
        <title>Navigation: Center View</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Sometimes it's a good idea to center the arrangeview to a certain point, may it be different points of interests within your project or just to get back to the playcursor/editcursor out of the view.
            
            For that, I added the function [CenterViewToCursor](usdocml://CenterViewToCursor).  
            Let's have a look at it:  
            

                        ultraschall.CenterViewToCursor(integer cursortype, optional number position) 

            
            It has two parameters, of which cursortype allows you to give the type of the cursor to center around:
                
                        1 - change arrangeview with edit-cursor centered
                        2 - change arrangeview with play-cursor centered
                        3 - change arrangeview with mouse-cursor-position centered
                        4 - centers arrangeview around the position given with parameter position
            
            The second parameter position is an optional one and only used, if cursortype is set to 4. It allows you to give a specific position in seconds, which the arrangeview shall be centered around.
            
            This functions only centers the given position/cursor-position to the arrangeview. It keeps the zoom-factor intact.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Navigation
        </chapter_context>
        <previous_chapter>Navigation_003_GotoMarkersRegionItemEdges</previous_chapter>
        <next_chapter>Navigation_005_Autoscroll_Followmode</next_chapter>
        <tags>documentation, arrangeview, navigation, playcursor, editcursor, position, center</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Navigation_005_Autoscroll_Followmode</slug>
        <title>Navigation: Autoscroll and Followmode</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Reaper allows you to set autoscrolling during playback/recording. It allows you to set it to continuous scrolling or to "page-wise"-scrolling.  
            This is quite flexible but hidden somewhat within the actions of Reaper. So I added the function [ToggleScrollingDuringPlayback](usdocml://ToggleScrollingDuringPlayback).  
            It turns on autoscrolling for playback and recording AND continuous scrolling.  
            Let's have a look at it:  
            

                        ultraschall.ToggleScrollingDuringPlayback(integer scrolling_switch, boolean move_editcursor, boolean goto_playcursor)

            
            The parameter scrolling\_switch allows you to turn on/off autoscrolling completely, that means, it will turn on autoscroll for playback and recording AND it sets autoscrolling to continuous scrolling.  
            The parameter move\_edit\_cursor allows you to set, if the editcursor shall be moved to the current playposition. This has an effect only, if scrolling\_switch is set to 1(off).  
            The last parameter goto\_playcursor allows you to change the view to the current playcursor-position, if you turn on autoscrolling. This has an effect only, if scrolling\_switch is set to 0(off).  
            
            When running the function, it changes, if neccessary, the toggle-states of the actions  
            
                        41817(View: Continuous scrolling during playback),  
                        40036(View: Toggle auto-view-scroll during playback) and   
                        40262(View: Toggle auto-view-scroll while recording), 
            which means, it sets if a certain autoscrolling behavior is turned on or not.  
            If you have your own custom actions toggling these actions, you probably shouldn't use this function. Otherwise it probably messes up your workflows.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Navigation
        </chapter_context>
        <previous_chapter>Navigation_004_CenterView</previous_chapter>
        <next_chapter>GetSetStates_Project_Track_Item_Env_001_Introduction</next_chapter>
        <tags>documentation, arrangeview, navigation, playcursor, editcursor, position, center</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>GetSetStates_Project_Track_Item_Env_001_Introduction</slug>
        <title>Get/Set States for Project, Tracks and Items</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            One of the long-term-goals of the Ultraschall-API is full access to all states within projects, tracks, items, envelopes, including all states only available in StateChunks.  
            As of the current version, all track-states and many project and item-states are get and settable.
            
            The functions all work after the same principle, with the first parameter being the object to get/set the state from/to (Projectfile, MediaItem-object, MediaTrack-object and TrackEnvelope-Object).
            
            The last parameter, which is an optional one, can be a StateChunk-representation of the object, like ProjectStateChunk, MediaItemStateChunk, TrackStateChunk, TrackEnvelopeStateChunk. This optional parameter will only be seen, when the first parameter(for the object) is set to nil.  
            That way, you can decide, whether to use the original-object or the StateChunk, whatever works better for you.  
            
            In Setting-State-functions, it is basically the same: the first parameter the object and the last parameter is the optional StateChunk(when the first parameter is set to nil). The parameters inbetween set the individual settings for that state.  
            
            
            Let's have a look at two example functions [GetProject_CursorPos](usdocml://GetProject_CursorPos) and [SetProject_CursorPos](usdocml://SetProject_CursorPos):  
            Get Project-State:  

                        number cursorpos = ultraschall.GetProject_CursorPos(string projectfilename_with_path, optional string ProjectStateChunk) 
                
            The first parameter is the filename with path to the RPP-Projectfile. When this is set to nil, you can pass a ProjectStateChunk(which is basically the content of the RPP-projectfile).
            
            Set Project-State:  
            
                        integer retval = ultraschall.SetProject_CursorPos(string projectfilename_with_path, number cursorpos, optional string ProjectStateChunk) 

            The first parameter is the filename with path to the RPP-Projectfile. When this is set to nil, you can pass a ProjectStateChunk(which is basically the content of the RPP-projectfile).
            The parameter in the middle, cursorpos, can be set by you. That way, the cursorposition of the Project/ProjectStateChunk can be set to the position you prefer.
            
            The same principle is for MediaTrack-states and MediaItem-states:

                        -- the first parameter either MediaItem or nil, the last parameter can be a MediaItemStateChunk when first parameter is nil
                        number length = ultraschall.GetItemLength(MediaItem MediaItem, optional string MediaItemStateChunk)
                        string MediaItemStateChunk = ultraschall.SetItemLength(MediaItem MediaItem, integer length, string MediaItemStateChunk)
                        
                        -- the first parameter either MediaTrack or nil, the last parameter can be a TrackStateChunk when first parameter is nil
                        integer lockedstate = ultraschall.GetTrackLockState(integer tracknumber, optional string TrackStateChunk)
                        boolean retval, string TrackStateChunk = ultraschall.SetTrackLockState(integer tracknumber, integer LockedState, optional string TrackStateChunk) 
            
            StateChunks can be gotten using reaper.GetTrackStateChunk(), reaper.SetTrackStateChunk(), reaper.GetItemStateChunk(), reaper.SetItemStateChunk(), reaper.GetEnvelopeStateChunk(), reaper.SetEnvelopeStateChunk().  
            To get ProjectStateChunks, you need to read the rpp-file, as currently there's no Get/SetProjectStateChunk-function in Reaper's own API.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Get/Set Project/Track/MediaItem-States
        </chapter_context>
        <previous_chapter>Navigation_005_Autoscroll_Followmode</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_001_Introduction</next_chapter>
        <tags>documentation, arrangeview, navigation, playcursor, editcursor, position, center</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_001_Introduction</slug>
        <title>MediaItems: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When working with MediaItems, it often was frustrating for me to code, how to get their MediaItem-objects. Especially when "mass-working" with dozens and more MediaItems.  
            So I wrote a set of functions to work with MediaItems more comfortably.
            
            These functions include getting MediaItem-objects by time AND track, [getting MediaItem-states](#GetSetStates_Project_Track_Item_Env_001_Introduction), editing, inserting, manipulating, spectral edit, previewing, RippleCut, RippleInsert, SectionCut, working with locked, selected items, applying Reaper-actions to MediaItems, etc.  
            
            When working with masses of MediaItems, I either use the datatypes [MediaItemArrays](#Datatypes_003_MediaItemArray) or [MediaItemStateChunkArrays](#Datatypes_004_MediaItemStateChunkArrays).  
            When passing over the tracks wanted, I use the datatype [trackstring](#Datatypes_002_trackstring).  
            
            All this stuff should help you getting and manipulating MediaItems much more easier.  
            
            Let's begin with getting items by time(range) and tracks.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>GetSetStates_Project_Track_Item_Env_001_Introduction</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_002_GetMediaItems</next_chapter>
        <tags>documentation, mediaitems, items, introduction</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_002_GetMediaItems</slug>
        <title>MediaItems: Getting MediaItems by Time and Tracks</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Let's face it, when editing items of a project in Reaper, you either click on the items or select them in a 2D-way, by drawing a boundary box around the items of your choice or using a time-selection.  
            What you do by that is selecting the items by time. What you also do is, selecting the items by track, as your boundary box may go over several tracks. Or you use a track-selection by clicking on the tracks you want.  
            In either way, you select them in a 2Dimensional way.
            Not with Reaper's own API. Sure, you can somehow choose the MediaItems by track or by project, but you can't select them by multiple tracks. And certainly not by a time-range.  
            
            This was annoying for me, so to address this, I wrote the two functions [GetMediaItemsAtPosition](usdocml://GetMediaItemsAtPosition) and [GetAllMediaItemsBetween](usdocml://GetAllMediaItemsBetween) (my favorite ones in this api, I have to admit ;) ).  
              
            Let's have a closer look at them.  
            
            **[GetMediaItemsAtPosition](usdocml://GetMediaItemsAtPosition)**:
            
                        integer number_of_items, array MediaItemArray, array MediaItemStateChunkArray 
                                                                       = ultraschall.GetMediaItemsAtPosition(number position, string trackstring)

            
            >This function gives you all items at position passed with parameter position and within the tracks given by parameter trackstring.  
            >It returns the number of items, an array with all MediaItems and an array with all StateChunks of the MediaItems returned.  
            >With this function, you can easily get the items from a certain position, without having to deal with looking into the MediaItem-objects for the correct time-position, or even have to care, where to get the corresponding tracks from an item.  
            >This function does this for you.
            
            But what, if you want to get the MediaItems inbetween a startingposition and an endposition?  
            For this, I wrote the function 
            
            **[GetAllMediaItemsBetween](usdocml://GetAllMediaItemsBetween)**:
            

                         integer count, array MediaItemArray, array MediaItemStateChunkArray = 
                                     ultraschall.GetAllMediaItemsBetween(number startposition, number endposition, string trackstring, boolean inside) 

            
            >which basically returns the same things, as GetMediaItemsAtPosition. The difference lies in the parameters.  
            >You can pass to the function a startposition and an endposition(which must be bigger than or equal startposition), [trackstrings](#Datatypes_002_trackstring), which is a string with all tracks, separated by commas as well as inside as parameters.
            >When you set inside to true, it will return only items that are completely within startposition and endposition. When setting inside to false, it will also return items, that are partially within start- and endposition, like items beginning before startposition or ending after endposition.
            
            With these two functions, getting items is much, much easier than before.
            
            The returned MediaItems, MediaItemArrays and MediaItemStateChunkArrays can then be passed over to other functions, who accept them, for "mass manipulation" of the MediaItems.
            
            In addition to them, I also added some more functions for getting MediaItems, namely:
            
               - [GetAllMediaItems](usdocml://GetAllMediaItems) - get all MediaItems from the project into a handy MediaItemArray, for further "mass-manipulation" of them.
               - [GetAllLockedItemsFromMediaItemArray](usdocml://GetAllLockedItemsFromMediaItemArray) - get all MediaItems that are locked, from a MediaItemArray
               - [GetAllMediaItemsFromTrack](usdocml://GetAllMediaItemsFromTrack) - get all MediaItems from a track, returned as MediaItemArray
               - [GetAllMediaItemsInTimeSelection](usdocml://GetAllMediaItemsInTimeSelection) - get all MediaItems in given tracks from the current time-selection
               - [GetAllSelectedMediaItems](usdocml://GetAllSelectedMediaItems) - gets all selected MediaItems as MediaItemArray
               - [GetSelectedMediaItemsAtPosition](usdocml://GetSelectedMediaItemsAtPosition) - gets all selected MediaItems in given tracks from a time-position
               - [GetSelectedMediaItemsBetween](usdocml://GetSelectedMediaItemsBetween) - gets all selected MediaITems in given tracks between start- and endposition
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_001_Introduction</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_003_Splitting</next_chapter>
        <tags>documentation, mediaitems, items, getting</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_003_Splitting</slug>
        <title>MediaItems: Splitting MediaItems by Time and Tracks</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Getting MediaItems by time and tracks is cool. Editing them by time and tracks is even better. For that, I also added some functions:  
            The easiest ones are [SplitMediaItems_Position](usdocml://SplitMediaItems_Position) and [SplitItemsAtPositionFromArray](usdocml://SplitItemsAtPositionFromArray)  
            Let's have a look at:  
            
            **[SplitMediaItems_Position](usdocml://SplitMediaItems_Position)**:
            
                            boolean retval, array MediaItemArray = ultraschall.SplitMediaItems_Position(number position, string trackstring, boolean crossfade)
            
            >This splits all items at position, that are in the tracks given by parameter trackstring. If you want to have the items  So if you want to split all items in tracks 1,3,4 at position 22, you type:
            
                            retval, MediaItemArray = ultraschall.SplitMediaItems_Position(22, "1,3,4", false)
            
            >There's another parameter crossfade. If you have it set to true or nil and have Automatic-Crossfade enabled (Preferences -> Media Item Defaults -> Overlap and crossfade items when splitting, length), crossfade will be done at the split.  
            >If you want to avoid that, set it to false and a normal split with fadein/fadeout will appear(if set in the preferences: Preferences -> Media Item Defaults -> Create automatic fade-in/fade-out for new items, length).  
            
            >This function returns, if splitting was successful and the newly "created"-right-hand-split-items as an MediaItemAray.
            
            **[SplitItemsAtPositionFromArray](usdocml://SplitItemsAtPositionFromArray):**  
            >The function SplitItemsAtPositionFromArray works quite similar, but with the difference, that you don't give tracks, but items to the function, that shall be split at position.
                
                            boolean retval, array MediaItemArray = ultraschall.SplitItemsAtPositionFromArray(number position, array MediaItemArray, boolean crossfade)
                
            >position is the position, at which an item shall be split. MediaItemArray is an array with all MediaItems, that shall be split, if possible. crossfade sets if automatic crossfade shall be applied to or not, just as in SplitMediaItems_Position above.  
            >This function will split only items, that have the position in them somewhere. That means, if you want to split at position 22 seconds, an item, that goes from 1 to 4 will not be split, an item from 18 to 25 will be split.
            
            >This function returns, if splitting was successful and the newly "created"-right-hand-split-items as an MediaItemAray. Only the right-hand-split-MediaItem of MediaItems, that could be split, will be returned. If a MediaItem could not be split(position outside MediaItemstart and MediaItemEnd), there will be no returned MediaItem for it then.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_002_GetMediaItems</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_004_Deleting</next_chapter>
        <tags>documentation, mediaitems, items, editing</tags>
    </US_DocBloc>
    
        <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_004_Deleting</slug>
        <title>MediaItems: Deleting MediaItems by Time and Tracks</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Deleting of MediaItems is often a useful thing. Unfortunately, this is inconvenient to do within the Reaper-API. The only such function is DeleteTrackMediaItem, but it requires you to give the function the track in which the MediaItem lies too. 
            But often, you want to have a function that simply deletes a MediaItem-object or deletes items at position from numerous tracks, etc.  
            So I added some functions, that make life easier: [DeleteMediaItem](usdocml://DeleteMediaItem), [DeleteMediaItemsFromArray](usdocml://DeleteMediaItemsFromArray), [DeleteMediaItems_Position](usdocml://DeleteMediaItems_Position) and [DeleteMediaItemsBetween](usdocml://DeleteMediaItemsBetween)
            
            In addition to deleting the MediaItems, all these functions return the statechunks of the deleted MediaItems. These statechunks contain an additional field 
            
                            "ULTRASCHALL_TRACKNUMBER"
            
            which contains the track, in which the MediaItem was located before deleting it.  
            This may help doing cut and paste functions, as otherwise, you lose the information, in which track a certain MediaItem was located.
            
            
            **[DeleteMediaItem](usdocml://DeleteMediaItem):**
            
                            boolean retval, string MediaItemStateChunk = ultraschall.DeleteMediaItem(MediaItem MediaItem)
            
            >This function is simple. Just pass the MediaItem that you want to delete to it and it will delete it. If no such MediaItem exists, it will return false.
            
            
            **[DeleteMediaItemsFromArray](usdocml://DeleteMediaItemsFromArray):**
            
                            boolean retval, array MediaItemArray = ultraschall.DeleteMediaItemsFromArray(array MediaItemArray)
                
            >This function might be more interesting if you want to delete a number of MediaItems at once. Just pass to it a MediaItemArray(like the one returned by functions like [GetAllMediaItemsBetween](usdocml://GetAllMediaItemsBetween))

            
            **[DeleteMediaItems\_Position](usdocml://DeleteMediaItems_Position):**
            
                            boolean retval, array MediaItemStateChunkArray = ultraschall.DeleteMediaItems_Position(number position, string trackstring)
                
            >This function deletes all items at position in the tracks, given by trackstring.  
            >If you want to delete all items at position 22, within track 1,4,8 and 9, you just type:
            
                            retval = ultraschall.DeleteMediaItems_Position(22, "1,4,8,9")
                
                
            **[DeleteMediaItems\_Position](usdocml://DeleteMediaItems_Position):**
            
                            boolean retval, array MediaItemStateChunkArray  = 
                                        ultraschall.DeleteMediaItems_Between(number startposition, number endposition, string trackstring, boolean inside)
            
            >This function deletes MediaItems between start and endposition, within the track given by parameter trackstring. You can use the parameter inside to set, if you want to delete only items that are completely within start and endposition(true) or also include items, that are only partially within start and endposition.  
            >This function works like [GetAllMediaItemsBetween](usdocml://GetAllMediaItemsBetween), with the additional benefit of deleting the MediaItems.  
            >Let's assume, you want to delete all MediaItems between position 33 and 98, within the tracks 3, 5, 10 and 14 and only the items that are completely within the position 33 and 98, you type:  
            
                            retval, MediaItemStateChunkArray  = ultraschall.DeleteMediaItems_Between(33, 98, "3,5,10,14", true)

            With all these functions, deleting MediaItems is now comfortable to do.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_003_Splitting</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_005_Section_And_Ripple_Cut</next_chapter>
        <tags>documentation, mediaitems, items, editing</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_005_Section_And_Ripple_Cut</slug>
        <title>MediaItems: SectionCut, RippleCut, RippleInsert</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            One of Reaper's real great features is Ripple-Edit. On of the big shortcomings, it only allows Ripple Cut all tracks, Ripple Cut one track, no Ripple Cut.  
            But what if you want to RippleCut two or more tracks, but not all of them? What, if you want to RippleCut only selected tracks? What if you just want to cut a section without rippling?  
            Impossible you say!  
            With naked Reaper, yes. But possible with the Ultraschall-API.  
            
            For that I added the following functions: [RippleCut](usdocml://RippleCut), [RippleCut_Reverse](usdocml://RippleCut_Reverse), [RippleInsert](usdocml://RippleInsert), [SectionCut](usdocml://SectionCut), [SectionCut_Inverse](usdocml://SectionCut_Inverse)  
            All these functions return a MediaItemStateChunkArray, where every StateChunk includes an additional entry "ULTRASCHALL_TRACKNUMBER", which holds the tracknumber, in which the cut MediaItem/piece of a MediaItem was originally located.  
            
            **[RippleCut](usdocml://RippleCut)**:
                
                            integer number_items, array MediaItemArray_StateChunk = 
                                ultraschall.RippleCut(number startposition, number endposition, string trackstring, boolean movemarkers, boolean moveenvelopepoints)
                
            >With this function, you can RippleCut between startposition, endposition within the tracks as given in trackstring. You can also decide, whether to move the markers and the envelope-points as well.  
            >This should give you total control in how RippleCut is behaving for your needs.  
            >Let's take an example. If you want to cut between seconds 20 and 50 in track 1,4,5,7, not moving the markers but the envelope-points, you type in this
            >Example:
                
                            number_items, MediaItemArray_StateChunk = ultraschall.RippleCut(20, 50, "1,4,5,7", false, true)
                
            >This cuts out the section between seconds 20 and 50 and moves everything after that toward the beginning of the project, to fill the gap of the cut section.
            
            **[RippleCut\_Reverse](usdocml://RippleCut_Reverse)**:
            
                            integer number_items, array MediaItemArray_StateChunk = 
                               ultraschall.RippleCut_Reverse(number startposition, number endposition, string trackstring, boolean movemarkers, boolean moveenvelopepoints)
                
            >With this function, you can RippleCut, but unlike RippleCut above, RippleCut_Reverse moves everything BEFORE the cut towards the end to fill the cut.  
            >Everything else is just the same as RippleCut.
            
            
            **[RippleInsert](usdocml://RippleInsert)**:
            
                            integer number_of_items, array MediaItemArray, number endpos_inserted_items = 
                                ultraschall.RippleInsert(number position, array MediaItemArray, string trackstring, boolean moveenvelopepoints, boolean movemarkers)
                
            >This function inserts the items in MediaItemArray at position within the tracks, given by trackstring. You can also decide, whether markers and envelope-points shall be moved.  
            >This is quite the opposite of RippleCut: it will split the items at position, move the items after the split towards the end of the project and include the MediaItems in MediaItemArray.  
            >The length of the movement is according the overall length of all MediaItems, beginning with the earliest and ending with the latest MediaItem-length in MediaItemArray.  
            >One additional note: MediaItems will only be included into the tracks they were originally located in, means: an item from track 1 will be included into track 1. The parameter trackstring can only be used to exclude items from certain tracks.   
            >So a trackstring "1,3,4" will only insert all items from tracks 1,3 and 4, leaving out all of the MediaItems from track 2.  
            >Example:  
            
                            number_of_items, MediaItemArray, endpos_inserted_items = ultraschall.RippleInsert(20, MediaItemArray, "1,4,9,10" false, false)
            
            >This will insert all MediaItems from MediaItemArray, ordered by their relative position, at position 20 seconds. Only the MediaItems from tracks 1,4,9,10 will be included. All others will be ignored.  
            >Markers and Envelopepoints will not move in this example.
            
            **[SectionCut](usdocml://SectionCut)**:
            
                            integer number_items, array MediaItemArray_StateChunk = ultraschall.SectionCut(number startposition, number endposition, string trackstring)
                
            >This function just cuts out the section between start and endposition in the tracks, given in trackstring, leaving a "gap" in it. Useful, when you don't want to ripple stuff.  
            >If you want to cut between seconds 77 and 99 in tracks 1,2,4,6 do it like in this
            >Example:
            
                            number_items, MediaItemArray_StateChunk = ultraschall.SectionCut(77, 99, "1,2,4,6")
                
            **[SectionCut_Inverse](usdocml://SectionCut_Inverse)**:
            
                            integer number_items_beforestart, array MediaItemArray_StateChunk_beforestart, integer number_items_afterend, array MediaItemArray_StateChunk_afterend = 
                                        ultraschall.SectionCut_Inverse(number startposition, number endposition, string trackstring)
            
            >This function cuts everything BEFORE AND AFTER start and endposition within the tracks given by trackstring. This is comparable to crop-functionality in graphic-applications like Photoshop, applied to MediaItems.  
            >If you have a 10 minute project, but want to use only the audio from seconds 60 to 89 in tracks 1,2,7,8 you type in this
            >Example:

                            number_items_beforestart, MediaItemArray_StateChunk_beforestart, number_items_afterend, MediaItemArray_StateChunk_afterend = 
                                                                                                            ultraschall.SectionCut_Inverse(60, 89, "1,2,7,8")
                
             >With that, everything before second 60 and everything after second 89 in tracks 1,2,7,8 will be deleted.  
             >In addition to that, the function returns a MediaItemStateChunkArray for both, the items cut before startposition and one for the items cut after endposition.  
             
             This should give you many additional use-cases into your hands.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_004_Deleting</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_006_Moving_Manipulating</next_chapter>
        <tags>documentation, mediaitems, items, editing</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_006_Moving_Manipulating</slug>
        <title>MediaItems: Moving and Manipulating</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Getting, splitting, editing and deleting MediaItems isn't enough. In fact, you also want to manipulate them. And you also want to be able to manipulate many of them at once.  
            Hence, I added lots of functions to manipulate MediaItems, like:  
                
            - Moving: [MoveMediaItemsAfter_By](usdocml://MoveMediaItemsAfter_By), [MoveMediaItemsBefore_By](usdocml://MoveMediaItemsBefore_By), [MoveMediaItemsBetween_To](usdocml://MoveMediaItemsBetween_To), [MoveMediaItems_FromArray](usdocml://MoveMediaItems_FromArray)  
            - Length: [ChangeLengthOfMediaItems_FromArray](usdocml://ChangeLengthOfMediaItems_FromArray), [ChangeDeltaLengthOfMediaItems_FromArray](usdocml://ChangeDeltaLengthOfMediaItems_FromArray)  
            - Offset: [ChangeOffsetOfMediaItems_FromArray](usdocml://ChangeOffsetOfMediaItems_FromArray), [ChangeDeltaOffsetOfMediaItems_FromArray](usdocml://ChangeDeltaOffsetOfMediaItems_FromArray)  
            
            **Moving**  
            >Let's have a look at the moving-MediaItems-functions.
            
            >**[MoveMediaItemsAfter_By](usdocml://MoveMediaItemsAfter_By)**
            
                            boolean retval = ultraschall.MoveMediaItemsAfter_By(number old_position, number change_position_by, string trackstring)
                
            >This function moves all MediaItems from old\_position and later by a number of seconds, as given by the parameter change\_position\_by.  
            >If change\_position\_by is negative, the MediaItems will be move towards the beginning of the project; a positive value will move the MediaItems toward the end.  
            >The parameter trackstring tells the function, in which tracks the MediaItems shall be moved.  
            
            >**[MoveMediaItemsBefore_By](usdocml://MoveMediaItemsBefore_By)**
            
                            boolean retval = ultraschall.MoveMediaItemsBefore_By(number old_position, number change_position_by, string trackstring)
               
            >This basically works like the MoveMediaItemsAfter_By above, with the difference, that it moves the MediaItems BEFORE old\_position.
            
            >**[MoveMediaItemsBetween_To](usdocml://MoveMediaItemsBetween_To)**
            
                            boolean retval = ultraschall.MoveMediaItemsBetween_To(number startposition, number endposition, number newposition, string trackstring, boolean inside)
            
            >This also moves MediaItems, but the MediaItems between startposition and endposition. Unlike the functions above, you give the new position in seconds, at which the MediaItems shall start. The relative-positions of the MediaItems will stay intact.  
            >The parameter inside allows you to tell the function, whether to include only MediaItems completely within start and endposition(true) or also MediaItems that are partially within start and endposition(false).  
            
            >**[MoveMediaItems_FromArray](usdocml://MoveMediaItems_FromArray)**
            
                            integer retval, number earliest_itemtime, number latest_itemtime = ultraschall.MoveMediaItems_FromArray(array MediaItemArray, number newposition)
            
            >This moves the MediaItems in MediaItemArray to the newposition. It will retain the relative positions of the MediaItems as well.
            
            **Length**  
            >You can change the length of the MediaItems with functioncalls of Reaper's own API already. I added functions, that allow you to change the length of multiple MediaItems at once, using MediaItemArray.
            >And not just the length to a given length, but also a deltalength.
            >Let's have a look.
            
            >**[ChangeLengthOfMediaItems_FromArray](usdocml://ChangeLengthOfMediaItems_FromArray)**
            
                            boolean retval = ultraschall.ChangeLengthOfMediaItems_FromArray(array MediaItemArray, number newlength)
                
            >This changes the length of all MediaItems in the MediaItemArray to newlength in seconds.  
            >Example:
            
                            MediaItemArray={}
                            MediaItemArray[1]=reaper.GetMediaItem(0,0)
                            MediaItemArray[2]=reaper.GetMediaItem(0,1)
                            MediaItemArray[3]=reaper.GetMediaItem(0,2)
                        
                            retval = ultraschall.ChangeLengthOfMediaItems_FromArray(MediaItemArray, 3)
                
            >This examplecode will change the length of all MediaItems in MediaItemArray to a length of 3 seconds.
            
            >**[ChangeDeltaLengthOfMediaItems_FromArray](usdocml://ChangeDeltaLengthOfMediaItems_FromArray)**
            
                            boolean retval = ultraschall.ChangeDeltaLengthOfMediaItems_FromArray(array MediaItemArray, number deltalength)
                
            >This changes the length of the MediaItems in MediaItemArray as well, BUT it will change the length BY deltalength in seconds. That means, if deltalength is 4, all MediaItems in the MediaItemArray will become longer by 4 seconds, if deltalength is -3, all MediaItems in MediaItemArray will become 3 seconds shorter(!)  
            >Example:
            
                            MediaItemArray={}
                            MediaItemArray[1]=reaper.GetMediaItem(0,0) -- let's assume, this MediaItem is 10 seconds long
                            MediaItemArray[2]=reaper.GetMediaItem(0,1) -- let's assume, this MediaItem is 30 seconds long
                            MediaItemArray[3]=reaper.GetMediaItem(0,2) -- let's assume, this MediaItem is 5 seconds long
                        
                            retval = ultraschall.ChangeDeltaLengthOfMediaItems_FromArray(MediaItemArray, 4)
                
            >This examplecode will change the length of all MediaItems in MediaItemArray by 4 seconds, so the first item is now 14 seconds long, the second 34 and the third 9 seconds.  
            
            **Offset**  
            >Just like the length of MediaItems, you can change the offset as well with functioncalls of Reaper's own API. I added functions, that allow you to change the length of multiple MediaItems at once, using MediaItemArray.
            >And not just the length to a given length, but also a deltalength.
            >Let's have a look.
            
            >**[ChangeOffsetOfMediaItems_FromArray](usdocml://ChangeOffsetOfMediaItems_FromArray)**
            
                            boolean retval = ultraschall.ChangeOffsetOfMediaItems_FromArray(array MediaItemArray, number newoffset)
                
            >This changes the offset of all MediaItems in the MediaItemArray to newoffset in seconds.  
            >Example:
            
                            MediaItemArray={}
                            MediaItemArray[1]=reaper.GetMediaItem(0,0)
                            MediaItemArray[2]=reaper.GetMediaItem(0,1)
                            MediaItemArray[3]=reaper.GetMediaItem(0,2)
                        
                            retval = ultraschall.ChangeOffsetOfMediaItems_FromArray(MediaItemArray, 3)
                
            >This examplecode will change the offset of all MediaItems in MediaItemArray to a the new offset of 3 seconds.
            
            >**[ChangeDeltaOffsetOfMediaItems_FromArray](usdocml://ChangeDeltaOffsetOfMediaItems_FromArray)**
            
                            boolean retval = ultraschall.ChangeDeltaOffsetOfMediaItems_FromArray(array MediaItemArray, number deltaoffset)
                
            >This changes the offset of the MediaItems in MediaItemArray as well, BUT it will change the offset BY deltaoffset in seconds. That means, if deltaoffset is 4, all MediaItems in the MediaItemArray will start 4 seconds later, if deltaoffset is -3, all MediaItems in MediaItemArray will start 3 seconds earlier(!)  
            >Example:
            
                            MediaItemArray={}
                            MediaItemArray[1]=reaper.GetMediaItem(0,0) -- let's assume, this MediaItem's offset starts at 10 seconds
                            MediaItemArray[2]=reaper.GetMediaItem(0,1) -- let's assume, this MediaItem's offset starts at 30 seconds
                            MediaItemArray[3]=reaper.GetMediaItem(0,2) -- let's assume, this MediaItem's offset starts at 0 seconds
                            
                            retval = ultraschall.ChangeDeltaOffsetOfMediaItems_FromArray(MediaItemArray, 4)
                
            >This examplecode will change the offset of all MediaItems in MediaItemArray by 4 seconds, so the first item's offset starts now at 14 seconds, the second 34 and the third 4 seconds.  
            
            Other functions for manipulating MediaItems:  

               - [SetItemsLockState](usdocml://SetItemsLockState) - sets MediaItems in a MediaItemArray to either locked or unlocked    
               - [AddLockStateToMediaItemStateChunk](usdocml://AddLockStateToMediaItemStateChunk) - sets the locked-state in a MediaItemStateChunk  
               - [AddLockStateTo_MediaItemStateChunkArray](usdocml://AddLockStateTo_MediaItemStateChunkArray) - sets the locked-state to the MediaItemStateChunks in a MediaItemStateChunkArray  
               - [SetMediaItemsSelected_TimeSelection](usdocml://SetMediaItemsSelected_TimeSelection) - sets MediaItems selected within time-selection  
               - [SelectMediaItems_MediaItemArray](usdocml://SelectMediaItems_MediaItemArray) - sets MediaItems in MediaItemArray to selected  
               - [DeselectMediaItems_MediaItemArray](usdocml://DeselectMediaItems_MediaItemArray) - sets MediaItems in MediaItemArray deselected  
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_005_Section_And_Ripple_Cut</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_007_Inserting</next_chapter>
        <tags>documentation, mediaitems, items, editing, moving, offset, modifying</tags>
    </US_DocBloc>
    

    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_007_Inserting</slug>
        <title>MediaItems: Inserting Items and Files</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Last, but not least, it would be nice to be able to insert MediaItems as well. And not just inserting them from a project, but also from files.  
            For that, I made: [InsertMediaItem_MediaItem](usdocml://InsertMediaItem_MediaItem), [InsertMediaItem_MediaItemStateChunk](usdocml://InsertMediaItem_MediaItemStateChunk), [InsertMediaItemArray](usdocml://InsertMediaItemArray), [InsertMediaItemStateChunkArray](usdocml://InsertMediaItemStateChunkArray), [InsertMediaItemFromFile](usdocml://InsertMediaItemFromFile), [InsertImageFile](usdocml://InsertImageFile)  
            
            Lets have a look at inserting MediaItems.
            
            >**[InsertMediaItem_MediaItem](usdocml://InsertMediaItem_MediaItem)**
            
                            integer retval, MediaItem MediaItem, number startposition, number endposition, number length 
                                        = ultraschall.InsertMediaItem_MediaItem(number position, MediaItem MediaItem, MediaTrack MediaTrack)
            
            >With this function, you can make a copy of an already existing MediaItem and insert at position into a certain track. It allows using MediaItems and MediaTracks of other projects than the current one, as well.  
            >Just give the position, at which to insert the MediaItem, the MediaItem to be included and the MediaTrack into which to include the MediaItem.  
            >It will return the newly created MediaItem, it's startposition, endposition and the length.  
            
            >**[InsertMediaItem_MediaItemStateChunk](usdocml://InsertMediaItem_MediaItemStateChunk)**
            
                            integer retval, MediaItem MediaItem 
                                        = ultraschall.InsertMediaItem_MediaItemStateChunk(number position, string MediaItemStateChunk, MediaTrack MediaTrack)
            
            >This is like InsertMediaItem_MediaItem, but uses a MediaItemStateChunk instead. The rest is just the same, including the possibility to insert the new MediaItem into a MediaTrack in another project than the current one.  
            
            >**[InsertMediaItemArray](usdocml://InsertMediaItemArray)**
            
                            integer number_of_items, array MediaItemArray = ultraschall.InsertMediaItemArray(number position, array MediaItemArray, string trackstring)
                            
            >This allows you to insert multiple items at once, that are stored in a MediaItemArray at position. With trackstring you can set, into which tracks to insert the MediaItems.  
            >There's a limitation, however: MediaItems will only be inserted into the tracks from where they originated from. That means, if you have MediaItems located in tracks 1-5 and you set trackstring to "1,2", only the MediaItems originating in tracks 1 and 2 will be inserted.  
            >I'm still looking into a better way to provide the track, in which to insert the MediaItems into other MediaTracks as well.  
            
            >**[InsertMediaItemStateChunkArray](usdocml://InsertMediaItemStateChunkArray)**
            
                            integer number_of_items, array MediaItemArray 
                                            = ultraschall.InsertMediaItemStateChunkArray(number position, array MediaItemStateChunkArray, string trackstring)

           >This works like InsertMediaItemArray, but it's inserting MediaItemStateChunks from the MediaItemStateChunkArray instead.  
           >In addition to that, it also lifts the track-limitation, when you insert the tracknumber into each MediaItemStateChunk using [SetItemUSTRackNumber_StateChunk](usdocml://SetItemUSTRackNumber_StateChunk), which is automatically done by [GetItem-functions](#Getting_Manipulating_Items_002_GetMediaItems) from the Ultraschall-API.  
           >The addition of the tracknumber is mandatory, otherwise the MediaItemStateChunk will not be inserted!  
           
           >**[InsertMediaItemFromFile](usdocml://InsertMediaItemFromFile)**
           
                            integer retval, MediaItem item, number endposition, integer numchannels, integer Samplerate, string Filetype
                               = ultraschall.InsertMediaItemFromFile(string filename, integer track, number position, number endposition, integer editcursorpos, optional number offset)
                               
           >This function allows you to insert a file as a new MediaItem into your project, including the tracknumber, position, endposition(if wanted), the editcursorposition and the offset, if wanted.  
           >Example:
           
                            retval, item, endposition, numchannels, Samplerate, Filetype = ultraschall.InsertMediaItemFromFile("C:\\file.wav", 1, 20, -1, 2, 0)
           
           >This example inserts the file file.wav into track 1, at position 20, with the length set to the length of the audio-file, the editcursorposition being put at the end of the new MediaItem and no offset-changes.  
           
           >With that, you can easily insert files into your project.
           
           >**[InsertImageFile](usdocml://InsertImageFile)**
           
                            boolean retval, MediaItem item = ultraschall.InsertImageFile(string filename_with_path, integer track, number position, number length, boolean looped)

           >This is a special function, focusing on inserting image-files into the project. You can set the track, position, length of the image-MediaItem and, if it shall be looped.  
           >If you don't loop it(looped=false), the MediaItem will have the length anyway, but the image will be shown only for 1 second in the VideoProcessor-window.  
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_006_Moving_Manipulating</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_008_Spectral_Edit</next_chapter>
        <tags>documentation, mediaitems, items, inserting, mediaitem, mediaitemstatechunk, image</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_008_Spectral_Edit</slug>
        <title>MediaItems: Programming Spectral Edit</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
           With Reaper v5.50c, the devs introduced a new feature, called, spectral editing, which is a cool feature to influence frequencies in a spectral view of a MediaItem.  
           But they didn't include some functions to program this feature. So I added them myself.
           
           The functions for using, manipulating, adding, deleting spectral-edits are: 
              [AddItemSpectralEdit](usdocml://AddItemSpectralEdit), [CountItemSpectralEdits](usdocml://CountItemSpectralEdits), [DeleteItemSpectralEdit](usdocml://DeleteItemSpectralEdit), [GetItemSpectralConfig](usdocml://GetItemSpectralConfig), [GetItemSpectralEdit](usdocml://GetItemSpectralEdit), [GetItemSpectralVisibilityState](usdocml://GetItemSpectralVisibilityState), [SetItemSpectralConfig](usdocml://SetItemSpectralConfig), [SetItemSpectralEdit](usdocml://SetItemSpectralEdit), [SetItemSpectralVisibilityState](usdocml://SetItemSpectralVisibilityState)  
           
           Let's go into this in more detail.
           
           >**[SetItemSpectralVisibilityState](usdocml://SetItemSpectralVisibilityState)**
           
           >To use the SpectralEdit-mode, you need to first enable visibility of it in a MediaItem. You can do this later too, but you will not see any of your changes, until you enable visibility first.
           
                            string MediaItemStateChunk = ultraschall.SetItemSpectralVisibilityState(integer itemidx, integer state, optional string MediaItemStateChunk)
                            
           >This function enables visibility of Spectral-Edit of item itemidx. The parameter state must be set to 1 to set to visible, or set to 0 to turn visibility off.  
           >The function returns the altered MediaItemStateChunk in any way.  
           >If you set itemidx to -1, you can use the optional parameter MediaItemStateChunk instead. This will add the corresponding entry for the visibility into the MediaItemStateChunk and returns the modified one.  
           
           
           Now that we have toggled the visibility of SpectralEdit, we might want to add SpectralEdit-instances to the MediaItem. For that we use:
           
           >**[AddItemSpectralEdit](usdocml://AddItemSpectralEdit)**
           
                            boolean retval, MediaItemStateChunk statechunk 
                                        = ultraschall.AddItemSpectralEdit(integer itemidx, number start_pos, number end_pos, number gain, number fade, 
                                                                          number freq_fade, number freq_range_bottom, number freq_range_top, integer h, 
                                                                          integer byp_solo, number gate_thres, number gate_floor, number comp_thresh, 
                                                                          number comp_exp_ratio, number n, number o, number fade2, number freq_fade2, 
                                                                          string MediaItemStateChunk)
                                                                          
           >This will add a SpectralEdit-instance into your MediaItem. You can add as many individual instances, as you want.  
           
           >As you can see, you can influence a hell lot of parameters for such a SpectralEdit-instance, so I will not explain them in detail here. I suggest you to read the accompanying doc-entry for [AddItemSpectralEdit](usdocml://AddItemSpectralEdit), which explains the parameters in more detail.  
           >Just some bits: 
           >Every Spectral-Edit-instance will be shown as a square/rectangle on top of the MediaItem. You can influence this rectangle's position and length, the frequency-ranges covered, the fades as well as all settings of all knobs appearing in it.  
           >And as the cherry on the top: you can also bypass and solo it.  
           >And, as the SetItemSpectralVisibilityState-function above, if you set itemidx to -1, you can add the Spectral-Edit-instance to a MediaItemStateChunk instead.  
           
           
           But what if you want to modify an already existing SpectralEdit-instance? Good question and I have a good answer to that:
           
           >**[SetItemSpectralEdit](usdocml://SetItemSpectralEdit)**
           
                            string MediaItemStateChunk 
                                        = ultraschall.SetItemSpectralEdit(integer itemix, integer spectralidx, number start_pos, number end_pos, number gain, 
                                                                          number fade, number freq_fade, number freq_range_bottom, number freq_range_top, 
                                                                          integer h, integer byp_solo, number gate_thres, number gate_floor, number comp_thresh, 
                                                                          number comp_exp_ratio, number n, number o, number fade2, number freq_fade2, 
                                                                          string MediaItemStateChunk)
                                                                          
           >This sets an already existing SpectralEdit-instance, and it probably reminds you very much of the AddItemSpectralEdit-function.   
           >However, there is a small difference in it, the second parameter spectralidx, which tells the function, which spectral-edit-instance you want to change, with 1 for the first.  
           >The rest is like AddItemSpectralEdit.  
           
           
           To delete such an instance, you can use the function:
           
           >**[DeleteItemSpectralEdit](usdocml://DeleteItemSpectralEdit)**
           
                            boolean retval, string MediaItemStateChunk = ultraschall.DeleteItemSpectralEdit(integer itemidx, integer spectralidx, string MediaItemStateChunk)
                            
           >With that, you can easily delete a SpectralEdit-instance, by giving the item's idx(itemidx) and the number of the SpectralEdit-instance(spectralidx).  
           >And, as most of the functions before: when setting itemidx to -1, you can use the optional parameter MediaItemStateChunk  
           
           
           To successfully set an already existing instance, you probably want to know, what current settings are in a SpectralEdit-instance.  
           For that, there is:
           
           >**[GetItemSpectralEdit](usdocml://GetItemSpectralEdit)**
           
                            number start_pos, number end_pos, number gain, number fade, number freq_fade, 
                            number freq_range_bottom, number freq_range_top, integer h, integer byp_solo, 
                            number gate_thres, number gate_floor, number comp_thresh, number comp_exp_ratio, 
                            number n, number o, number fade2, number freq_fade2 
                                        = ultraschall.GetItemSpectralEdit(integer itemidx, integer spectralidx, string MediaItemStateChunk)
                                        
           >This returns all settings you can set with AddItemSpectralEdit and SetItemSpectralEdit, by giving the item's idx within the project(itemidx) and the SpectralEdit-instance(spectralidx).  
           >And you know the drill: when setting itemidx to -1, you can pass a MediaItemStateChunk to the function.
           
           Some other functions for SpectralEdit-management are:  
           
              - [GetItemSpectralVisibilityState](usdocml://GetItemSpectralVisibilityState) - to get, if SpectralEdit is visible for this MediaItem  
              - [SetItemSpectralConfig](usdocml://SetItemSpectralConfig) - to set the resolution(FFT-size) of the SpectralEdit of the MediaItem  
              - [GetItemSpectralConfig](usdocml://GetItemSpectralConfig) - to get the current resolution(FFT-size) of the SpectralEdit of the MediaItem  
              - [CountItemSpectralEdits](usdocml://CountItemSpectralEdits) - to count the number of currently existing SpectralEdit-instances in a MediaItem  
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_007_Inserting</previous_chapter>
        <next_chapter>Getting_Manipulating_Items_009_Miscellaneous</next_chapter>
        <tags>documentation, mediaitems, items, spectral, edit, add, count, delete, set, visibility, resolution, fft</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Getting_Manipulating_Items_009_Miscellaneous</slug>
        <title>MediaItems: Miscellaneous</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Still not enough? Well, I've added numerous other functions, and I want to introduce you to some of the gems included.  
            Feel free to browse through the [Functions-Reference](US_Api_Functions.html) to find more.  
            
            What about, previewing MediaItems and files? Use this:
            
            >**[PreviewMediaItem](usdocml://PreviewMediaItem)**
            
                            boolean retval = ultraschall.PreviewMediaItem(MediaItem MediaItem, integer Previewtype)
                            
            >This previews an existing MediaItem, which means: Reaper will play it, regardless of what you hear in your project currently.  
            >You can also set, where you want to have it previewed, through the MediaExplorer, the MediaItem itself, through the volume-settings of the track, in which it lies and through the track, in which it lies(including FX and such).  
            >You can just play one MediaItem at a time, unless you play one through the MediaExplorer and one through another previewing-type.  
            
            If you want to preview a file not in the current project, you can use:
            
            >**[PreviewMediaFile](usdocml://PreviewMediaFile)**
            
                            boolean retval = ultraschall.PreviewMediaFile(string filename_with_path)
                            
            >which will simply play the file you gave using filename\_with\_path.
            
            To stop any preview, just use 
            
            >**[StopAnyPreview](usdocml://StopAnyPreview)**
            
                            ultraschall.StopAnyPreview()
                            
            >which stops any previewing, be it from a MediaItem or an external mediafile.
            
            What about applying Actions to MediaItems? Use this:
            
            >**[ApplyActionToMediaItem](usdocml://ApplyActionToMediaItem)**
            
                            boolean retval = ultraschall.ApplyActionToMediaItem(MediaItem MediaItem, string actioncommandid, 
                                                                                integer repeat_action, boolean midi, optional HWND MIDI_hwnd)
                                                                                
            >which allows applying main and midi-editor-actions to MediaItem. Just pass the command\_id/action\_command\_id to the parameter.  
            >With parameter repeat\_action, you can set, how often the action shall be applied to the MediaItem.  
            >To apply MIDI-Editor, actions, set midi=true and pass over a HWND of the used MIDI-Editor, using Reaper's own API function [MIDIEditor_GetActive](Reaper_Api_Documentation.html#MIDIEditor_GetActive).  
            
            To apply action to multiple MediaItems, use:
            
            >**[ApplyActionToMediaItemArray](usdocml://ApplyActionToMediaItemArray)**
            
                            boolean retval = ultraschall.ApplyActionToMediaItemArray(MediaItemArray MediaItemArray, string actioncommandid, 
                                                                                     integer repeat_action, boolean midi, optional HWND MIDI_hwnd)
                            
            >which works just the same as ApplyActionToMediaItem, but uses a [MediaItemArray](#Datatypes_003_MediaItemArray) that includes the MediaItems to be affected.  
            
            In addition to actions, you can also apply functions to MediaItems:
            
            >**[ApplyFunctionToMediaItemArray](usdocml://ApplyFunctionToMediaItemArray)**
            
                            table returnvalues 
                                    = ultraschall.ApplyFunctionToMediaItemArray(MediaItemArray MediaItemArray, function functionname, 
                                                                                        functionparameters1, ..., functionparametersn)
            
            >You just pass to it the MediaItemArray, the functionname, the parameters for the function functionname.  
            >Keep in mind: if a parameter of functionname shall hold the MediaItem, you need to set the accompanying parameter to nil,  ApplyFunctionToMediaItemArray will
            >automatically insert the appropriate MediaItem at this nil parameter.
            
            What else? What about Normalizing MediaItems? Use this:
            
            >**[NormalizeItems](usdocml://NormalizeItems)**
            
                            integer retval = ultraschall.NormalizeItems(array MediaItemArray)
                            
            >Just pass to it a MediaItemArray, that holds all MediaItems to be normalized.
            
            And last, but not least: What about applying MediaItemStateChunks to MediaItems? Use this:
            
            >**[ApplyStateChunkToItems](usdocml://ApplyStateChunkToItems)**
            
                            boolean retval, integer skippeditemscount, array skipped_MediaItemStateChunkArray 
                                    = ultraschall.ApplyStateChunkToItems(array MediaItemStateChunkArray, boolean undostate)
                                    
            >This applies the MediaItemStateChunks in MediaItemStateChunkArray to the appropriate MediaItems. That means, if a StateChunk is of a certain, existing MediaItem, the function will apply the StateChunk to the MediaItem.  
            >This function is especially helpful, when mass manipulating StateChunks and wanting to mass-apply the changed ones back.  
            >Easy to do now.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            MediaItems
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_008_Spectral_Edit</previous_chapter>
        <next_chapter>1FileManagement_001_Introduction</next_chapter>
        <tags>documentation, mediaitems, items, preview, apply actions, apply function, normalize, apply statechunks</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>1FileManagement_001_Introduction</slug>
        <title>File Management: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Even if file-management isn't that hard to program in Lua, it is quite inconvenient. Especially for "normal" use-cases, it is often a drag to always go through the four steps, checking if file exists, open file, read/write, close file.  
            Wouldn't it be cool, to have functions to do it for you?
            
            Well now, there are, as the Ultraschall-API includes 28 functions to do it for you.  
            These functions include functions for reading and writing, copying them.  
            You can also check for valid filetypes, for valid directories, can count files and directories in paths, get paths and files in a path, and get length or number of lines in a file.  
            
            With that, you can do a lot of file-operation quite easy, without having to dig through the little details of the Lua-Reference-Manual.
            
            Let's start with reading files.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            File Management
        </chapter_context>
        <previous_chapter>Getting_Manipulating_Items_009_Miscellaneous</previous_chapter>
        <next_chapter>FileManagement_002_Read</next_chapter>
        <tags>documentation, files, filemanagement, introduction</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>FileManagement_002_Read</slug>
        <title>File Management: Read</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            To read files, I included some nice functions, like: [ReadFullFile](usdocml://ReadFullFile), [ReadBinaryFile](usdocml://ReadBinaryFile), [ReadBinaryFileFromPattern](usdocml://ReadBinaryFileFromPattern), [ReadBinaryFileUntilPattern](usdocml://ReadBinaryFileUntilPattern),  
                                                                 [ReadFileAsLines_Array](usdocml://ReadFileAsLines_Array), [ReadLinerangeFromFile](usdocml://ReadLinerangeFromFile), [ReadValueFromFile](usdocml://ReadValueFromFile), [ReadBinaryFile_Offset](usdocml://ReadBinaryFile_Offset)  
                                                                 
            Let's start with the function probably used the most:
            
            >**[ReadFullFile](usdocml://ReadFullFile)**
            
                            string contents, integer length_of_file, integer number_of_lines = ultraschall.ReadFullFile(string filename_with_path, boolean binary)
            
            > This reads a file fully and returns it's contents to the return-variable contents. It will also return the length of the file.  
            > If you set the parameter binary to true, it will read the files as binary files; if set to false or nil, it will read the file either until the end or until a eof-character comes up.  
            > If you're dealing with textfiles, set it to false or nil, otherwise to true.
            
            If you want to return all lines from a textfile, that have a certain character-pattern in them, use this function:
            
            >**[ReadValueFromFile](usdocml://ReadValueFromFile)**
            
                            string contents, string linenumbers, integer numberoflines, integer number_of_foundlines = 
                                                                ultraschall.ReadValueFromFile(string filename_with_path, string value)
                            
            > This reads a file as textfile and returns it. When you give parameter value a string, it will return all lines from the file, that contain this string.  
            > The returned values are contents, the linenumbers returned as a comma-separated-csv, the total number of lines in the file and the number of lines found and returned  
            > This should help you to read only the lines useful for you, however, it is much slower than ReadFullFile() due the massive pattern-matching used in it.  
            > So, even if you can read the full file with that, better use ReadFullFile when you want the full file returned.  
            
            If you want to return everything from a pattern to the end of a file, use:
            
            >**[ReadBinaryFileFromPattern](usdocml://ReadBinaryFileFromPattern)**
            
                            integer length, string content = ultraschall.ReadBinaryFileFromPattern(string input_filename_with_path, string pattern)
            
            > with this function, you can read a file from a pattern onwards. That means, the function searches for the first(!) instance of pattern and returns the file from that pattern until the end of the file.
            
            Similar to this is:

            >**[ReadBinaryFileUntilPattern](usdocml://ReadBinaryFileUntilPattern)**
            
                            integer length, string content = ultraschall.ReadBinaryFileUntilPattern(string input_filename_with_path, string pattern)
            
            > which reads a file until(!) a certain pattern is found in it and returns this. That means, it returns the file from it's start until the pattern.
            
            But what if you want to read a file from a start-offset to an endoffset? Use this:

            >**[ReadBinaryFile_Offset](usdocml://ReadBinaryFile_Offset)**
            
                            integer length, string content = 
                                    ultraschall.ReadBinaryFile_Offset(string input_filename_with_path, integer startoffset, integer numberofbytes)
            
            > This function returns the contents of the file from startoffset(in Bytes) until startoffset+numberofbytes.  
            > If you set number of bytes to -1, the function will return the file from startoffset to it's end.  
            > Positive value in startoffset will be related to the beginning of the file. If you want to return the file from a startoffset related to the end of the file,  
            > use negative value for startoffset.  
            > A startoffset of -1 is for the end of the file, -2 for the last byte in the file, -3 for the second to last byte in the file, etc.  
            > Even with negative startoffset, parameter numberofbytes will count from the startoffset to startoffset+numberofbytes.  
            > If the startoffset+numberofbytes reach or cross the end of the file, it will return a shorter string.  
            > To check, whether it returned the requested length, check the returnvalue length.  
            > Returnvalue content holds the requested part of the file  
            
            When you have a textfile and you want to work with it on an individual line-basis, use:  
            
            >**[ReadFileAsLines_Array](usdocml://ReadFileAsLines_Array)**
            
                            array contents, boolean correctnumberoflines, integer number_of_lines = 
                                    ultraschall.ReadFileAsLines_Array(string filename_with_path, integer firstlinenumber, integer lastlinenumber)
            
            > This returns a textfile, split into it's individual lines put into an array. You can also set the linenumbers, that you want to have returned.  
            > If the linenumbers returned are fewer than you requested, correctnumberoflines will be false, otherwise it will be true.  
            
            If you want to have the lines returned in one string, use the following instead:
            
            >**[ReadLinerangeFromFile](usdocml://ReadLinerangeFromFile)**
            
                            string contents, boolean correctnumberoflines, integer number_of_lines = 
                                     ultraschall.ReadLinerangeFromFile(string filename_with_path, integer firstlinenumber, integer lastlinenumber)
            
            > This works basically the same as ReadFileAsLines_Array, but returns the found-lines as a newline-separated string.
            
            
            These functions should fulfill most of your daily file-read-usecases.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            File Management
        </chapter_context>
        <previous_chapter>FileManagement_001_Introduction</previous_chapter>
        <next_chapter>FileManagement_003_Write</next_chapter>
        <tags>documentation, files, filemanagement, read</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>FileManagement_003_Write</slug>
        <title>File Management: Write</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Reading files is cool, writing files is cool as well, so I added some for exactly that: [WriteValueToFile](usdocml://WriteValueToFile), [WriteValueToFile_Insert](usdocml://WriteValueToFile_Insert), [WriteValueToFile_Replace](usdocml://WriteValueToFile_Replace), [WriteValueToFile_InsertBinary](usdocml://WriteValueToFile_InsertBinary), [WriteValueToFile_ReplaceBinary](usdocml://WriteValueToFile_ReplaceBinary)
            
            Let's start with the function, that you'll probably use the most for writing:
            
            >**[WriteValueToFile](usdocml://WriteValueToFile)**
            
                            integer retval = ultraschall.WriteValueToFile(string filename_with_path, string value, optional boolean binarymode, optional boolean append)
                            
            > This writes a value to filename\_with\_path. Optionally, you can control, if the file shall be written as binary-file and if value shall be appended to the current contents of the file.  
            > Default is, file will be stored as binary and value replaces the current contents of the file.

            To insert values into a textfile, use:
            
            >**[WriteValueToFile_Insert](usdocml://WriteValueToFile_Insert)**
            
                            integer retval = ultraschall.WriteValueToFile_Insert(string filename_with_path, integer linenumber, string value)
                            
            > This inserts value after the line, given by parameter linenumber. This works only for textfiles, not for binary-files.  
            
            To replace parts of a textfile, use:
            
            >**[WriteValueToFile_Replace](usdocml://WriteValueToFile_Replace)**
            
                            integer retval = ultraschall.WriteValueToFile_Replace(string filename_with_path, integer startlinenumber, integer endlinenumber, string value)
            
            > This replaces the lines between (including)-startnumber and (including)-endlinenumber with the parameter value. This works only for textfiles, not for binary-files.
            
            For binary-files, we have dedicated functions for that as well:
            
            >**[WriteValueToFile_InsertBinary](usdocml://WriteValueToFile_InsertBinary)**
            
                            integer retval = ultraschall.WriteValueToFile_InsertBinary(string filename_with_path, integer byteposition, string value)
                            
            > This inserts parameter value at the fileoffset given by parameter byteposition. This works for binary-files and for textfiles(though textfiles may cause issues at some points).
            
            To replace contents of a binaryfile, you can use:
            
            >**[WriteValueToFile_ReplaceBinary](usdocml://WriteValueToFile_ReplaceBinary)**
            
                            integer retval = ultraschall.WriteValueToFile_ReplaceBinary(string filename_with_path, integer startbyteposition, integer endbyteposition, string value)
                            
            > This inserts parameter value between (including) startbyteposition and (including)endbyteposition. This works for binary-files and for textfiles(though textfiles may cause issues at some points).
            
            This should make saving files easier than having to code it completely yourself by hand.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            File Management
        </chapter_context>
        <previous_chapter>FileManagement_002_Read</previous_chapter>
        <next_chapter>FileManagement_004_Analyse</next_chapter>
        <tags>documentation, files, filemanagement, write</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>FileManagement_004_Analyse</slug>
        <title>File Management: Analyse</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Sometimes, you want to know more about the contents of a file. For that, I included some functions as well: [CountLinesInFile](usdocml://CountLinesInFile), [GetLengthOfFile](usdocml://GetLengthOfFile), [CheckForValidFileFormats](usdocml://CheckForValidFileFormats), [OnlyFilesOfCertainType](usdocml://OnlyFilesOfCertainType)
            
            For reading files, you probably want to know the length of the files or number of lines in it. For that you can use:
            
            >**[GetLengthOfFile](usdocml://GetLengthOfFile)**
            
                            integer lengthoffile = ultraschall.GetLengthOfFile(string filename_with_path)
            
            > This returns the length of the file in bytes.
            
            >**[CountLinesInFile](usdocml://CountLinesInFile)**
            
                            integer linesinfile = ultraschall.CountLinesInFile(string filename_with_path)
            
            > This returns the number of lines in a textfile.
            
            If you want to know, what type a certain file is, you can use:
            
            >**[CheckForValidFileFormats](usdocml://CheckForValidFileFormats)**
            
                            string fileformat, boolean supported_by_reaper, string mediatype = ultraschall.CheckForValidFileFormats(string filename_with_path)
            
            > This returns the type of a file, which is either  
            
                            JPG, PNG, GIF, LCF, ICO, WAV, AIFF, ASF/WMA/WMV, MP3, MP3 -ID3TAG, FLAC, MKV/MKA/MKS/MK3D/WEBM, AVI, RPP_PROJECT, unknown 
            
            > and it returns, if the filetype is supported by Reaper and what kind of mediatype the file is, which is either
            
                            Image, Audio, Audio/Video, Video, Reaper
                            
            But what, if you want to know all files of a certain types in a filelist(like the file in a directory)? Use this:
            
            >**[OnlyFilesOfCertainType](usdocml://OnlyFilesOfCertainType)**
            
                            integer foundfilecount, array foundfilearray = ultraschall.OnlyFilesOfCertainType(array filearray, string filetype)
                  
            > This returns all files from parameter filearray, that are of a certain filetype.
            > Create an array with all filenames you want to check for and use this for parameter filearray. In the parameter filetype, you can use one of:
            
                            JPG, PNG, GIF, LCF, ICO, WAV, AIFF, ASF/WMA/WMV, MP3, MP3 -ID3TAG, FLAC, MKV/MKA/MKS/MK3D/WEBM, AVI, RPP_PROJECT, unknown 
            
            > After that, the function returns an array with all files, that are of the filetype you gave to parameter filetype.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            File Management
        </chapter_context>
        <previous_chapter>FileManagement_003_Write</previous_chapter>
        <next_chapter>FileManagement_005_Misc</next_chapter>
        <tags>documentation, files, filemanagement, analyse</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>FileManagement_005_Misc</slug>
        <title>File Management: Misc</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Last, but not least, I added many other useful functions regarding file-management, like:
            
            - [CountDirectoriesAndFilesInPath](usdocml://CountDirectoriesAndFilesInPath) - this counts all files and directories in a path
            - [CreateValidTempFile](usdocml://CreateValidTempFile) - this creates a valid tempfile
            - [DirectoryExists](usdocml://DirectoryExists) - checks, if a certain path exists
            - [DirectoryExists2](usdocml://DirectoryExists2) - another version of a check, if a certain path exists
            - [GetAllDirectoriesInPath](usdocml://GetAllDirectoriesInPath) - returns all directorynames in a path as array
            - [GetAllFilesnamesInPath](usdocml://GetAllFilesnamesInPath) - returns all filenames in a path as array
            - [GetPath](usdocml://GetPath) - separates a filename from it's path
            - [MakeCopyOfFile](usdocml://MakeCopyOfFile) - copies a textfile
            - [MakeCopyOfFile_Binary](usdocml://MakeCopyOfFile_Binary) - copies a binaryfile
            - [GetReaperWorkDir](usdocml://GetReaperWorkDir) - returns the current workdir of Reaper, where files(without a path) will be created in
            - [SetReaperWorkDir](usdocml://SetReaperWorkDir) - sets the current workdir of Reaper, where files(without a path) will be created in(needs Reaper-restart)
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            File Management
        </chapter_context>
        <previous_chapter>FileManagement_004_Analyse</previous_chapter>
        <next_chapter>Project_Management_001_Introduction</next_chapter>
        <tags>documentation, files, filemanagement, miscellaneous</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Project_Management_001_Introduction</slug>
        <title>Project Management: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Beside of many functions to [read and set project-states](#GetSetStates_Project_Track_Item_Env_001_Introduction) in RPP-files and ProjectStateChunks, I also added some other things to work with projects.
            
            - [NewProjectTab](usdocml://NewProjectTab) - creates a new project-tab
            - [CheckForChangedProjectTabs](usdocml://CheckForChangedProjectTabs) - checks, if projecttabs have been changed/added/removed(explained in the next chapter)
            - [ConvertOldProjectToCurrentReaperVersion](usdocml://ConvertOldProjectToCurrentReaperVersion) - simply loads a project into Reaper and saves it again, to update the project to Reaper's current projectfile-style
            - [CountProjectTabs](usdocml://CountProjectTabs) - count the current project-tabs
            - [EnumProjects](usdocml://EnumProjects) - returns Project and projectfilename of an opened project; more streamlined alternative to Reaper's own EnumProjects
            - [GetCurrentTimeLengthOfFrame](usdocml://GetCurrentTimeLengthOfFrame) - returns the length in seconds of a frame in a project
            - [GetLengthOfFrames](usdocml://GetLengthOfFrames) - returns the length of a number of frames in a project
            - [GetOutputFormat_RenderCfg](usdocml://GetOutputFormat_RenderCfg) - get the output-format of a render-string as used by [Rendering functions](#Rendering_002_About_Renderstrings)
            - [GetProject_Tabs](usdocml://GetProject_Tabs) - returns all projects and project-filenames currently opened in tabs
            - [IsValidProjectStateChunk](usdocml://IsValidProjectStateChunk) - checks, whether a string is a valid ProjectStateChunk(i.e. you read an rpp-roject into a variable, you can check this)
            - [IsValidReaProject](usdocml://IsValidReaProject) - checks, whether an object is a valid ReaProject-object
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Project Management
        </chapter_context>
        <previous_chapter>FileManagement_005_Misc</previous_chapter>
        <next_chapter>Project_Management_002_Check_Changed_Projecttabs</next_chapter>
        <tags>documentation, projectmanagement, introduction </tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Project_Management_002_Check_Changed_Projecttabs</slug>
        <title>Project Management: Check for changed projecttabs</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Sometimes, you want to know, if projecttabs have been reordered, closed, opened, created. For this, I created the function
            
            >**[CheckForChangedProjectTabs](usdocml://CheckForChangedProjectTabs)**
            
                            boolean retval, integer countReorderedProj, array reorderedProj, integer countNewProj, 
                                                         array newProj, integer countClosedProj, array closedProj 
                                                                      = ultraschall.CheckForChangedProjectTabs(boolean update)
            
            > This checks, if there are changed projecttabs and the number of these changes.  
            > Let's go into details:  
            > When you run a script, that includes the Ultraschall-API, the API creates a list of the currently existing projecttabs.  
            > When you run this function, it will check this internal list and compare, if projects have been added, reordered or closed since them.  
            > 
            > This function returns if there's a change, into the return-value retval. The other return-values return  
            
            >> - the number of reordered projects(countReorderedProj),  
            >> - an array with all reorderd Projects(reorderedProj),  
            >> - the number of new projects(countNewProj),  
            >> - an array with all newly created/opened projects(newProj),  
            >> - the number of closed projects(countClosedProj) and  
            >> - an array with all closed projects(closedProj)  
            
            When you want to update this internal list, you should set parameter update to true, otherwise set it to false.
            
            That way, you can for instance work with newly created projects, to automatically add things to projects, that can't be added using TemplateProjects.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        <chapter_context>
            Project Management
        </chapter_context>
        <previous_chapter>Project_Management_001_Introduction</previous_chapter>
        <next_chapter>ColorManagement_001_Introduction</next_chapter>
        <tags>documentation, projectmanagement, projecttabs, changed, reordered, created, closed</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ColorManagement_001_Introduction</slug>
        <title>Color Management: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Reaper has a lot of cool themeing abilities, which allows you to customize most of the design of Reaper yourself.  
            One of these things is: customized colors.
            
            Unfortunately, Reaper has it's own way to deal with color. In fact there are two main ways of dealing with color:
            
               - native color
               - r,g,b-color
               
            The r,g,b-color is, as you are used to it: you have a red-color-value, a green-color-value and a blue-color-value, each going from 0 to 255.  
            The higher the value of one of these colors, the brighter that part of the color becomes.  
            
               - If red is 255 and green and blue are 0, the color will become pure red.  
               - If the color is red=0, green=60, blue=0 then the color will be green, but a darker shade of green.  
               - If all three colors are the same, they are either white(all three are 255), black(all three are 0), or gray(all three are somewhere between 1 and 254), where the brightness is influenced by how high the value is.
            
            The native-color is a system-dependent color-value used by Reaper. It is more difficult to understand, but basically it is 
            
                    red+(green\*green)+(blue\*blue\*blue)|0x1000000
                
            Or it isn't, because on MacOS, you need to reverse red and blue, so it becomes 
                
                    blue+(green\*green)+(red\*red\*red)|0x1000000  
            
            Why that is, is a mystery to me, but there's a function by Reaper, that does the correct conversion for you automatically: reaper.ColorToNative(r,g,b)|0x1000000  
            But you always need to add that |0x1000000 after the function, and I usually forget, how to write that properly.  
            
            There's also some other nice stuff in many gfx-applications, that is completely missing from Reaper's own color-functions: adjusting brightness, saturation and contrast of colors, which would be helpful for adjusting track-colors and item-colors and such.
            
            And what about manipulating multiple colors at once?
            
            So I thought, why not adding functions, that make that stuff easier?
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Color Management
        </chapter_context>
        <previous_chapter>Project_Management_002_Check_Changed_Projecttabs</previous_chapter>
        <next_chapter>ColorManagement_002_Native_Color_Conversion</next_chapter>
        <tags>documentation, color management, native, introduction</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ColorManagement_002_Native_Color_Conversion</slug>
        <title>Color Management: Native Color Conversion</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            For color-conversion into a system-dependent native-color, there are the functions: 
               >[ConvertColor](usdocml://ConvertColor), [ConvertColorReverse](usdocml://ConvertColorReverse), [ConvertColorToMac](usdocml://ConvertColorToMac), [ConvertColorFromMac](usdocml://ConvertColorFromMac), [ConvertColorToWin](usdocml://ConvertColorFromWin), [ConvertColorFromWin](usdocml://ConvertColorFromWin), [ConvertGFXToColor](usdocml://ConvertGFXToColor), [ConvertColorToGFX](usdocml://ConvertColorToGFX)  
        
            Let's start with standard-color-conversion, from/to system-dependent native-colors:
        
               >**[ConvertColor](usdocml://ConvertColor)**
           
                                integer colorvalue, boolean retval = ultraschall.ConvertColor(integer r, integer g, integer b)
                            
               >This function converts red, green and blue-values into the native-color of your system. Unlike Reaper's own function, you don't need to add |0x1000000, which makes it easier to use.  
               >If for one reason or another the conversion fails, it will return 0 and false as returnvalues.  
               >If you want to convert it into a Mac-native-color-value while on Windows or a Windows one while on Mac, just swap the r and the b values.
            
               >**[ConvertColorReverse](usdocml://ConvertColorReverse)**
            
                                integer r, integer g, integer b, boolean retval = ultraschall.ConvertColorReverse(integer colorvalue)

               >This one converts a native-color-value into it's original red, green and blue-colorvalues. If color-conversion failed, the returnvalue retval is false, else it is true.
            
            But what if you want to convert a color from/to a native-Mac-color, even if you're using Windows or Linux? And what if you're using Mac and want to convert from/to the native-color for Windows/Linux?  
            For that, I added four functions:  
                
               >**[ConvertColorToMac](usdocml://ConvertColorToMac)**
               
                                integer mac_colorvalue, boolean retval = ultraschall.ConvertColorToMac(integer red, integer green, integer blue)
               
               >This converts a red, green, blue-value to a Mac-native-colorvalue. This works on Windows, Mac and Linux the same way.  
               >Will set returnvalue retval to false, if conversion failed; if conversion succeeded, it will be set to true.
               
               >**[ConvertColorFromMac](usdocml://ConvertColorFromMac)**
               
                                integer red, integer green, integer blue, boolean retval = ultraschall.ConvertColorFromMac(integer mac_colorvalue)

               >This converts a Mac-native colorvalue into it's red, green and blue-values. If retval is true then conversion was successful; if false, conversion failed.
                                
               >**[ConvertColorToWin](usdocml://ConvertColorToWin)**
               
                                integer win_linux_colorvalue, boolean retval = ultraschall.ConvertColorToWin(integer red, integer green, integer blue)
               
               >This converts a red, green, blue-value to a Windows/Linus-native-colorvalue. This works on Windows, Mac and Linux the same way.  
               >Will set returnvalue retval to false, if conversion failed; if conversion succeeded, it will be set to true.
               
               >**[ConvertColorFromWin](usdocml://ConvertColorFromWin)**
               
                                integer red, integer green, integer blue, boolean retval = ultraschall.ConvertColorFromWin(integer win_colorvalue)
                                
               >This converts a Windows/Linux-native colorvalue into it's red, green and blue-values. If retval is true then conversion was successful; if false, conversion failed.
               
            If you want to convert the red, green, blue, alpha-colorvalues with a range from 0 to 255, into colorvalues useable by the gfx.functions for [gfx.init](Reaper_Api_Documentation.html#lua_gfx.init)-windows (range 0 ... 1), you can use the following functions:
        
               >**[ConvertColorToGFX](usdocml://ConvertColorToGFX)**
               
                                number r, number g, number b, number a = ultraschall.ConvertColorToGFX(integer r, integer g, integer b, integer a)
               
               >This converts red, green, blue, alpha-values(0-255) into gfx-useable functions(0-1). Simply pass the values between 0 to 255 to the function.
               >These returned values can be used by [gfx.set](Reaper_Api_Documentation.html#lua_gfx.set).
               
               >**[ConvertGFXToColor](usdocml://ConvertGFXToColor)**
               
                                integer r, integer g, integer b, integer a = ultraschall.ConvertGFXToColor(number r, number g, number b, number a)
               
               >This converts red, green, blue, alpha-values(0-255) into gfx-useable functions(0-1). Simply pass the values between 0 to 255 to the function.
               
            With that, you can convert color-values into all color-values you ever want to have.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Color Management
        </chapter_context>
        <previous_chapter>Project_Management_001_Introduction</previous_chapter>
        <next_chapter>ColorManagement_003_Brightness_Saturation_Contrast</next_chapter>
        <tags>documentation, color management, native, color, conversion</tags>
    </US_DocBloc>
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ColorManagement_003_Brightness_Contrast_Saturation</slug>
        <title>Color Management: Brightness, Contrast and Colorsaturation</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Sometimes, you want to alter brightness, contrast or saturation of a color but have no idea, how to do that. For that, I added three functions that do that for you: 
            [ChangeColorBrightness](usdocml://ChangeColorBrightness), [ChangeColorContrast](usdocml://ChangeColorContrast), [ChangeColorSaturation](usdocml://ChangeColorSaturation)
            
            Let's start with adjusting the brightness:
            
            >**[ChangeColorBrightness](usdocml://ChangeColorBrightness)**
            
                                integer red, integer green, integer blue, boolean retval = 
                                        ultraschall.ChangeColorBrightness(integer r, integer g, integer b, 
                                                                          integer bright_r, optional integer bright_g, optional integer bright_b)
                                                                          
            >This function alters the brightness of a color. Just pass to it the old r,g,b-values and the by how much the color shall be brightened/darkened.  
            >To do this, set bright\_r, bright\_g and bright\_b to the new deltavalue. If these delta-values are negative, the color will become darker, if positive, it will become brighter.  
            >If you pass only bright\_r and omit bright\_g and bright\_b, the deltavalue set by bright\_r will be applied to red, green and blue at the same time.  
            >To prevent that, set bright\_g and bright\_b to 0.  
            >It returns the changed colorvalues and the returnvalue retval, which will tell you, if changing saturation was successful(true) or not(false).
            
            Sometimes adjusting brightness is not enough, so let's see, how we can alter contrast of a color:
            
            >**[ChangeColorContrast](usdocml://ChangeColorContrast)**
            
                                integer red, integer green, integer blue, boolean retval = 
                                        ultraschall.ChangeColorContrast(integer r, integer g, integer b, 
                                                                        integer Minimum_r, optional integer Maximum_r, 
                                                                        optional integer Minimum_g, optional integer Maximum_g, 
                                                                        optional integer Minimum_b, optional integer Maximum_b)

            >This function alters the contrast of a color.
            >It does it by assuming, that the color-value you pass to it, will be seen as the center of the brightness-range, while Minimum\_color and Maximum\_color are the minimum and maximum of the color-range available.  
            >For example: If you pass as parameter r the value 100, the function will assume, that the current minimum is at 0 and the current maximum is at 255.
            >When you pass now Minimum\_r as 0 and Maximum\_r as 200, it will calculate the red-colorvalue in relation to the new minimum and maximum. That means, it will divide the new range of 200 by 255 and multiply this value by the old red-value.  
                    
                               new_redcolor = ((Maximum_r-Minimum_r)/255)*r
                               
            >The more apart Minimum and Maximum become, the stronger the contrast, the closer they become to each other, the weaker the contrast.  
            >You can also influence the brightness by making Maximum and Minimum higher(making it brighter) or lower(making it darker).  
            
            >If you use only the Minimum\_r and Maximum\_r-parameters, these will be applied to red, green and blue at the same time.  
            >To prevent that, set Minimum\_g to 0 and Minimum\_b to 0, Maximum\_g to 255 and Maximum\_b to 255.

            To intensify or desaturate color, you can use the following function:
            
            >**[ChangeColorSaturation](usdocml://ChangeColorSaturation)**
            
                                integer red, integer green, integer blue, number median, boolean retval = 
                                        ultraschall.ChangeColorSaturation(integer r, integer g, integer b, integer delta)
            
            >This saturates/desaturates a color-value.  
            >Using it is easy, just pass red, green and blue to it, as well as a delta-value that affects the saturation.  
            >To desaturate, set the value for delta negative, to saturate, make delta a positive value.  
            >It will return the new color-values(r,g,b), as well as the median. It also returns retval, which will tell you, if changing saturation was successful(true) or not(false).  
            
            >The function calculates the new saturation-value by first calculating a median-brightness-value from the red, green and blue-value.   
            >For desaturation: after that, it will add delta to values below median and subtract delta from values above delta.  
            >For saturation: after that, it will subtract delta from values below median and add delta to values above delta.  
            >  
            >By that, it will desaturate or saturate.  
            
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Color Management
        </chapter_context>
        <previous_chapter>ColorManagement_002_Native_Color_Conversion</previous_chapter>
        <next_chapter>ColorManagement_004_ColorTables</next_chapter>
        <tags>documentation, color management, brightness, contrast, saturation, color, conversion</tags>
    </US_DocBloc>

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ColorManagement_004_ColorTables_Introduction</slug>
        <title>Color Management: Working with Colortables</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When working with multiple colors at once, you can use a [ColorTable](#Datatypes_007_ColorTable), which can hold multiple colors, as 0-255 integer- and 0-1 float-representation, as well as the current native-color.
            Such colortables can be used to apply colors to track-colors or item-colors.
            This is still work in progress but will become more elaborated over time.
            
            There are currently multiple color-table-functions available, like: [CreateColorTable](usdocml://CreateColorTable), [CreateSonicRainboomColorTable](usdocml://CreateSonicRainboomColorTable), [IsValidColorTable](usdocml://IsValidColorTable), [ApplyColorTableToTrackColors](usdocml://ApplyColorTableToTrackColors)
            
            Over time, I intend to add functions to these colortables as well, so adding, removing, altering and changing colors in the colortable(like brightness, saturation and such) is possible more easily.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Color Management
        </chapter_context>
        <previous_chapter>ColorManagement_003_Brightness_Contrast_Saturation</previous_chapter>
        <next_chapter>ColorManagement_005_ColorTables_Creating_And_Checking</next_chapter>
        <tags>documentation, color management, native, color, colortables, introduction</tags>
    </US_DocBloc>    

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ColorManagement_005_ColorTables_Creating_And_Checking</slug>
        <title>Color Management: Creating Colortables</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Let's create such a new [ColorTable](#Datatypes_007_ColorTable):
            
            >**[CreateColorTable](usdocml://CreateColorTable)**
            
                                array ColorTable = ultraschall.CreateColorTable(integer startr, integer startg, integer startb, 
                                                                                integer endr, integer endg, integer endb, integer number_of_steps)
            
            >This creates a new ColorTable with colors from a given color-range. You set startr, startg, startb to the first color, endr, endg and endb to the last color and the number\_of\_steps from the first to the last color.  
            >After that, you'll have a ColorTable with number\_of\_steps-colors from startcolor to endcolor. So the following code returns a colortable with 50 shades of gray from black to white:  
            
                                ColorTable = ultraschall.CreateColorTable(0, 0, 0, 255, 255, 255, 50)
            
            >If you've created multiple ColorTables and want to have them combined into one, just combine them using the function [ConcatIntegerIndexedTables](usdocml://ConcatIntegerIndexedTables).
            
            >**[CreateSonicRainboomColorTable](usdocml://CreateSonicRainboomColorTable)**
            
                                array ColorTable = ultraschall.CreateSonicRainboomColorTable()
                                
            >This is a simple function, that creates a ColorTable in Ultraschall's "Sonic Rainboom"-style.
            
            If you want to check, whether a certain table is a valid ColorTable, you can easily check this, using the function IsValidColorTable:
            
            >**[IsValidColorTable](usdocml://IsValidColorTable)**
            
                                boolean retval = ultraschall.IsValidColorTable(array ColorTable)
                                
            >Simply pass a table to check for and it will return, whether it is a valid ColorTable(true) or nor(false)
            
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Color Management
        </chapter_context>
        <previous_chapter>ColorManagement_004_ColorTables_Introduction</previous_chapter>
        <next_chapter>ColorManagement_006_ColorTables_Applying</next_chapter>
        <tags>documentation, color management, native, color, colortables, create, check</tags>
    </US_DocBloc>    
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ColorManagement_006_ColorTables_Applying</slug>
        <title>Color Management: Applying Colortables</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Now, that we've created a new ColorTable, we might want to apply it somewhere, like tracks or items. 
            For that, we have: [ApplyColorTableToTrackColors](usdocml://ApplyColorTableToTrackColors) and [ApplyColorTableToItemColors](usdocml://ApplyColorTableToItemColors)  
            
            Let's bring some colors into our lives:
            
            >**[ApplyColorTableToTrackColors](usdocml://ApplyColorTableToTrackColors)**
            
                                boolean retval = ultraschall.ApplyColorTableToTrackColors(array ColorTable, integer Spread, integer StartTrack, integer EndTrack)
            
            >This applies a ColorTable to tracks to colorize them. To do that, [create a Colortable](#ColorManagement_005_ColorTables_Creating) and pass it to this function to parameter ColorTable.  
            >The parameter Spread decides, whether to apply a ColorTable once(0), or cyclic/repeating(1 or nil) or whether to spread the colors over all tracks equally(2).  
            >The final parameters decide, to which tracks to apply this, starting from track StartTrack to EndTrack. Use nil as StartTrack to automatically use the first, nil as EndTrack to automatically use the last track in the project.  
            
            >**[ApplyColorTableToItemColors](usdocml://ApplyColorTableToItemColors)**
            
                                boolean retval = ultraschall.ApplyColorTableToItemColors(array ColorTable, integer Spread, MediaItemArray MediaItemArray)
                                
            >This applies a ColorTable to MediaItems and works basically as the ApplyColorTableToTrackColors-function above, with the exception, that you pass MediaItems as MediaItemArray.  
            >The rest is the same, pass to the function a ColorTable and in the parameter Spread, how to spread/cycle the colors over the MediaItems.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Color Management
        </chapter_context>
        <previous_chapter>ColorManagement_005_ColorTables_Creating_And_Checking</previous_chapter>
        <next_chapter>ObjectExtStates_001_Introduction</next_chapter>
        <tags>documentation, color management, native, color, colortables, apply, item, track</tags>
    </US_DocBloc>        

    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ObjectExtStates_001_Introduction</slug>
        <title>Object Extension States: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            In Reaper, you can add notes to MediaItems. Unfortunately: only one note per MediaItem. But how often do you want to store multiple notes associated with a MediaItem?  
            And what about MediaTracks? Currently, Reaper does not support storing notes for MediaTracks.  
            
            And I thought, why not adding additional Notes for MediaTracks and MediaItems or any other object that has a guid, storing them either globally using extstates or project-locally using Project-Extension-States?  
            Maybe as easy to use, as you are used from ExtStates?  
            So I added that.  
            
            With these extstates, you can add more than one note/information to MediaTracks, MediaItems or certain Guids.
            
            Let's go more into detail.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Extension States
        </chapter_context>
        <previous_chapter>ColorManagement_006_ColorTables_Applying</previous_chapter>
        <next_chapter>ObjectExtStates_002_MediaTrackExtensionStates</next_chapter>
        <tags>documentation, extension states, extstate</tags>
    </US_DocBloc>    
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ObjectExtStates_002_MediaTrackExtensionStates</slug>
        <title>Object Extension States: MediaTrack Extension States</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Setting and getting ExtStates for MediaTracks is quite easy to do, using: [GetTrackExtState](usdocml://GetTrackExtState), [SetTrackExtState](usdocml://SetTrackExtState)  
            Let's set a new ExtState:
            
            >**[SetTrackExtState](usdocml://SetTrackExtState)**
            
                                boolean retval = ultraschall.SetTrackExtState(MediaTrack track, string key, string value, boolean overwrite)
                                
            >This sets a new extstate to a certain MediaTrack. This is simple to use. Just pass a MediaTrack-object, a key and it's value to it.  
            >The last parameter overwrite tells the function, if it shall overwrite an already existing extstate.  
            >The returnvalue tells you, if setting the extstate was successful(true) or not(false).
            
            Getting the extstate is also real easy:
            
            >**[GetTrackExtState](usdocml://GetTrackExtState)**
            
                                boolean retval, string value = ultraschall.GetTrackExtState(MediaTrack track, string key)
                                
            >This gets an existing extstate of a MediaTrack. Just pass to it the MediaTrack, whose extstate you want, as well as the key to the value.  
            >It will return two retvals, of which the first one tells, if getting the extstate was successful or not, and the second holds the actual value as a string.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Extension States
        </chapter_context>
        <previous_chapter>ObjectExtStates_001_Introduction</previous_chapter>
        <next_chapter>ObjectExtStates_003_MediaItemExtensionStates</next_chapter>
        <tags>documentation, extension states, extstate, mediatrack</tags>
    </US_DocBloc>    
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ObjectExtStates_003_MediaItemExtensionStates</slug>
        <title>Object Extension States: MediaItem Extension States</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Setting and getting ExtStates for MediaItems works the same as for MediaTracks, using: [GetItemExtState](usdocml://GetItemExtState), [SetItemExtState](usdocml://SetItemExtState)  
            Let's set a new ExtState:
            
            >**[SetItemExtState](usdocml://SetItemExtState)**
            
                                boolean retval = ultraschall.SetItemExtState(MediaItem item, string key, string value, boolean overwrite)
                                
            >This sets a new extstate to a certain MediaItem. This is simple to use. Just pass a MediaItem-object, a key and it's value to it.  
            >The last parameter overwrite tells the function, if it shall overwrite an already existing extstate.  
            >The returnvalue tells you, if setting the extstate was successful(true) or not(false).
            
            Getting the extstate is also real easy:
            
            >**[GetItemExtState](usdocml://GetItemExtState)**
            
                                boolean retval, string value = ultraschall.GetItemExtState(MediaItem item, string key)
                                
            >This gets an existing extstate of a MediaItem. Just pass to it the MediaItem, whose extstate you want, as well as the key to the value.  
            >It will return two retvals, of which the first one tells, if getting the extstate was successful or not, and the second holds the actual value as a string.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Extension States
        </chapter_context>
        <previous_chapter>ObjectExtStates_002_MediaTrackExtensionStates</previous_chapter>
        <next_chapter>ObjectExtStates_050_OtherExtensionStates</next_chapter>
        <tags>documentation, extension states, extstate, mediaitem</tags>
    </US_DocBloc>    

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>ObjectExtStates_050_OtherExtensionStates</slug>
        <title>Object Extension States: Other Extension States</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Sometimes, getting/setting extstates for objects isn't enough. In fact, you want sometimes store extstates for objects who have a certain guid.  
            Even further: you want to store them not only within the current project, but globally.  
            For that, I added the functions: [GetGuidExtState](usdocml://GetGuidExtState), [SetGuidExtState](usdocml://SetGuidExtState)
            
            >**[SetGuidExtState](usdocml://SetGuidExtState)**
            
                                integer retval = ultraschall.SetGuidExtState(string guid, string key, string value, integer savelocation, boolean overwrite, boolean persists)
                                
            >This sets an extstate for a specific guid(which can be obtained by many Reaper-objects). In addition to the guid, you pass the key and value to it.  
            >The other parameters control where and how to store the extstate.
            >Parameter savelocation decides, whether to store it globally or locally within the current project only. When storing it globally, it can be accessed from outside the project as well.  
            >Parameter overwrite decides, whether to overwrite an already existing extstate or not.  
            >Parameter persists controls, whether a global extstate shall be still available after restart of Reaper. It will be ignored, when the extstate is a local-project-one.
            
            Getting such an extstate for guids isn't that difficult at all:
            
            >**[GetGuidExtState](usdocml://GetGuidExtState)**
            
                                integer retval, string value = ultraschall.GetGuidExtState(string guid, string key, integer savelocation)
                                
            >This gets an extstate associated with a certain guid. Pass to the function the guid and the key to get returned.  
            >Parameter savelocation decides, whether to read the extstate from the global extstates or the local extstates. That means, you can have two guid-extstates of the same name, with one being global and one being project-local.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Extension States
        </chapter_context>
        <previous_chapter>ObjectExtStates_003_MediaItemExtensionStates</previous_chapter>
        <next_chapter>Background_Scripts_001_Introduction</next_chapter>
        <tags>documentation, extension states, extstate, other, guid</tags>
    </US_DocBloc>    
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Background_Scripts_001_Introduction</slug>
        <title>Background Scripts: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Some things in Reaper can't be solved easily without having something monitoring in the background. So to include some new features otherwise impossible, I added some background-scripts, that can be easily run using:
            
            >**[RunBackgroundHelperFeatures](usdocml://RunBackgroundHelperFeatures)**
            
                                ultraschall.RunBackgroundHelperFeatures()
                                
            >This starts the background-scripts, that provide additional features.
            
            Without having the background-scripts started, some functions will always produce error-codes.  
            Features that use these background-scripts are:
            
            >**[GetLastCursorPosition](usdocml://GetLastCursorPosition)** - gets the last editcursor-position before the current one. Helpful for left-click-triggered scripts, who change the editcursorposition due the mouseclick
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Background-Scripts
        </chapter_context>
        <previous_chapter>ObjectExtStates_050_OtherExtensionStates</previous_chapter>
        <next_chapter>Cough_Mute_Buttons_001_Introduction</next_chapter>
        <tags>background scripts, run, introduction</tags>
    </US_DocBloc>    
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Cough_Mute_Buttons_001_Introduction</slug>
        <title>Cough and Mute Buttons/Actions: Introduction</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            When recording over a long period of time, especially when recording interviews for podcasts, radio and such, you probably run into the issue that someone is coughing or drinking something. Though both of these things are important, a recording of it is usually not wished.  
            For that, Reaper provides a Mute-Envelope for each track, which allows to mute a track for a period of time and unmute it again. This muting can be recorded, so it will remain even after the recording is finished.  
            Problem is: You need to "arm" the mute-envelope first, otherwise any mute-information as send by e.g. MIDI-devices will not be added to the mute-envelope and therefor is lost after the recording.  
            In some cases, this behavior is a good thing and gives you flexibility when to record the mutes and when not, but for casual users, who do not want to have this kind of freedom, this can be really hard to use.  
            
            So I added some functions, that add mute-points into a mute-envelope regardless of it's arming-state. This should make using the mute-envelope for your benefits much easier.  
            
            Let's go into more detail.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Cough and Mute-Buttons
        </chapter_context>
        <previous_chapter>Background_Scripts_001_Introduction</previous_chapter>
        <next_chapter>Cough_Mute_Buttons_002_Toggling_Mute</next_chapter>
        <tags>cough, mute, buttons, introduction</tags>
    </US_DocBloc>    
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Cough_Mute_Buttons_002_Toggling_Mute</slug>
        <title>Cough and Mute Buttons/Actions: Toggling Mute</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            The first and foremost thing you probably want is actually muting a mute-envelope of a track, for that there are the two functions: [ToggleMute](usdocml://ToggleMute), [ToggleMute_TrackObject](usdocml://ToggleMute_TrackObject)
            
            >**[ToggleMute](usdocml://ToggleMute)**
            
                                    integer retval = ultraschall.ToggleMute(integer track, number position, integer state)
                                    
            >This mutes a given track using the mute-envelope of the track(not the mute-buttons in the TCP/MCP).  
            >Just pass over the tracknumber(with 1 for the first track, 2 for the second, etc!), the position, at which to insert the mute-point and the state of muting.  
            >The state of muting can be either muted(0) or unmuted(1)
            
            To mute a certain MediaTrack-object, you can use the function:
            
            >**[ToggleMute_TrackObject](usdocml://ToggleMute_TrackObject)**
            
                                    integer retval = ultraschall.ToggleMute_TrackObject(MediaTrack trackobject, number position, integer state)
                                    
            >This works the same as ToggleMute, but accepts a MediaTrack instead of a tracknumber. The rest is the same, position for the position of the new mutepoint and state for mute(0) or unmute(1).
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Cough and Mute-Buttons
        </chapter_context>
        <previous_chapter>Background_Scripts_001_Introduction</previous_chapter>
        <next_chapter>Cough_Mute_Buttons_003_FindingMutes</next_chapter>
        <tags>cough, mute, buttons, introduction</tags>
    </US_DocBloc>    
    
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Cough_Mute_Buttons_003_FindingMutes</slug>
        <title>Cough and Mute Buttons/Actions: Toggling Mute</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Toggling is cool, but you probably want to know, if toggling is even necessary of where the next/previous mute-object currently is.  
            For that, I added the functions: [IsMuteAtPosition](usdocml://IsMuteAtPosition), [IsMuteAtPosition_TrackObject](usdocml://IsMuteAtPosition_TrackObject), [GetNextMuteState](usdocml://GetNextMuteState), [GetNextMuteState_TrackObject](usdocml://GetNextMuteState_TrackObject), [GetPreviousMuteState](usdocml://GetPreviousMuteState), [GetPreviousMuteState_TrackObject](usdocml://GetPreviousMuteState_TrackObject)
            
            If you want to know, how many mute-points exist in a track, you can use:
            
            >**[CountMuteEnvelopePoints](usdocml://CountMuteEnvelopePoints)**
            
                                    integer retval = ultraschall.CountMuteEnvelopePoints(integer track)
                                    
            >This counts the envelope-points of a mute-envelope in a given track.
            
            To check, if there's already a mute-point at a given position in a track, you can use the IsMuteAtPosition-function.
            
            >**[IsMuteAtPosition](usdocml://IsMuteAtPosition)**
            
                                    boolean retval, optional integer envIDX, optional number envVal  = ultraschall.IsMuteAtPosition(integer tracknumber, number position)
                                    
            >This checks, whether there is a mute-point in track tracknumber at position. Parameter tracknumber is 1-based, with 1 for the first track, 2 for the second, etc.  
            >If there is a mutepoint at the position, it will return the index of the mute-point and it's current value.  
            >It will return false in case of an error
            
            With this, you can check, whether adding/toggling at the position is actually necessary.
            
            If you want to know, which is the next or previous mute-point, you can use:
            
            >**[GetNextMuteState](usdocml://GetNextMuteState)**
            
                                    integer envIDX, number envVal, number envPosition = ultraschall.GetNextMuteState(integer track, number position)
                                    
            >Returns the attributes of the next mute-point from position. Just give the tracknumber and the position and it returns the corresponding indexnumber, value and position.  
            >It will return -1, if no such mute-point exists
            
             >**[GetPreviousMuteState](usdocml://GetPreviousMuteState)**
            
                                    integer envIDX, number envVal, number envPosition = ultraschall.GetPreviousMuteState(integer track, number position)
                                    
            >Returns the attributes of the previous mute-point from position. Just give the tracknumber and the position and it returns the corresponding indexnumber, value and position.  
            >It will return -1, if no such mute-point exists
            
            If you want to use a trackobject rather than the tracknumber, you can use the functions:
            
             - [IsMuteAtPosition_TrackObject](usdocml://IsMuteAtPosition_TrackObject) - like IsMuteAtPosition, but uses a MediaTrack-object instead of a tracknumber
             - [GetNextMuteState_TrackObject](usdocml://GetNextMuteState_TrackObject) - like GetNextMuteState, but uses a MediaTrack-object instead of a tracknumber
             - [GetPreviousMuteState_TrackObject](usdocml://GetPreviousMuteState_TrackObject) - like GetPreviousMuteState, but uses a MediaTrack-object instead of a tracknumber
             
            With that, you should get a good overview over the mute-points in your project.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Cough and Mute-Buttons
        </chapter_context>
        <previous_chapter>Cough_Mute_Buttons_002_Toggling_Mute</previous_chapter>
        <next_chapter>Cough_Mute_Buttons_004_DeletingMutes</next_chapter>
        <tags>cough, finding, next, previous, is at position, mute, buttons, introduction</tags>
    </US_DocBloc>    

    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
        <slug>Cough_Mute_Buttons_004_DeletingMutes</slug>
        <title>Cough and Mute Buttons/Actions: Toggling Mute</title>
        <description markup_type="markdown" markup_version="1.0.1" indent="default">
            Being able to set and toggle and find mute-points is quite good, but sometimes, you want to get rid of them as well.  
            For that, I added the functions: [DeleteMuteState](usdocml://DeleteMuteState), [DeleteMuteState_TrackObject](usdocml://DeleteMuteState_TrackObject)
            
            >**[DeleteMuteState](usdocml://DeleteMuteState)**
            
                                    boolean retval = ultraschall.DeleteMuteState(integer tracknumber, number position)
                                    
            >This deletes a mute-point in track with tracknumber at position. It returns false, if there is no mute-point to delete.
            >Parameter tracknumber is 1-based, with 1 for track 1, 2 for track 2, etc.
            
            To delete a mute-point using a MediaTrack-object, you can use instead:
            
            >**[DeleteMuteState_TrackObject](usdocml://DeleteMuteState_TrackObject)**
            
                                    boolean retval = ultraschall.DeleteMuteState_TrackObject(MediaTrack MediaTrack, number position)
                                    
            >Works exactly like DeleteMuteState, but expects a MediaTrack-object instead of a tracknumber.
        </description>
        <target_document>ReaperApiConcepts</target_document>
        <source_document></source_document>
        </chapter_context>
        <chapter_context>
            Cough and Mute-Buttons
        </chapter_context>
        <previous_chapter>Cough_Mute_Buttons_003_FindingMutes</previous_chapter>
        <next_chapter></next_chapter>
        <tags>cough, delete, mute, buttons, introduction</tags>
    </US_DocBloc>    
    
</USDocML>
>**[](usdocml://)**